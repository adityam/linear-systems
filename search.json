[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Course Outline",
    "section": "",
    "text": "Instructor\n\n\nAditya Mahajan\nOffice Hours: TBD\n\n\nTeaching Assistants\n\n\nTBD\n\n\nLectures\n\n\n10:05am–11:25am Tuesday, Thursday (ENGMC 11)\n\n\nTutorials\n\n\n8:35am–10:25am Friday, (ENGMC 11)\n\n\n\nEveryone must be registered for the tutorial. Tutorials start from the second week of classes.\n\nLabs\n\n\n1:35pm-3:25pm Monday (TR 4090)\n\n\n\n\n3:35pm–5:25pm Monday (TR 4090)\n\n\n\n\n1:35pm–3:25pm Tuesday (TR 4090)\n\n\n\n\n1:35pm–3:25pm Wednesday (TR 4090)\n\n\n\n\n1:35pm–3:25pm Friday (TR 4090)\n\n\n\nEveryone must be registered for one lab. Labs start from the second week of classes.\nThe labs have to be done in groups of two. The groups will be formed in the first week of classs.\n\nPrerequisites\n\n\nECSE 206 (Fundamentals of Signals and Systems)\nECSE 210 (Electrical Circuits 2)\n\n\nCommunication\n\nUse the discussion board on myCourses for all questions related to the course. Only personal emails related to medical exceptions for missing a deliverable will be answered.\n\n\n\n\n\n\n\n\nAttribute\nDescription\nStatus\n\n\n\n\nKB\nKnowledge Base for Engineering\nDeveloped\n\n\nPA\nProblem Analysis\nDeveloped\n\n\nIN\nInvestigation\nDeveloped\n\n\nDE\nDesign\nIntroduced\n\n\n\nUpon the successful completion of this course, the student students will have demonstrated the ability to:\n\nApply time- and frequency-domain tools to analyze linear time-invariant systems (KB, PA)\nDesign controllers based on state-space methods and lead-lag compensators to meet time-response specifications (KB, PA, DE)\nUse Matlab to analyze and synthesize controllers for linear time-invariant systems (DE, IN)\n\n\n\n\n\n\n\n\n\n\n\nWeek\nMaterial Covered\n\n\n\n\n1\nReview of LTI Systems and Laplace Transforms  Reading: Nise Ch. 2\n\n\n2\nState-space modeling, canoncial forms, transfer function of state space models  Reading: William and Lawrence Ch. 1 and Ch. 2\n\n\n3\nPole Zero Plot Step response of first and second order systems, dominant pole approximation  Reading: Nise Ch. 4\n\n\n4\nMatrix exponential and solution of matrix differential equations, time response of state space models\n\n\n5\nPole placement, controllability, and state feedback\n\n\n6\nLuenberger observer, observability, output feedback, and separation principle\n\n\n7\nReview and Mid-Term\n\n\n8\nRouth-Hurwitz stability criterion. Special cases: zero in first column, row of zeros.\n\n\n9\nBlock diagrams, rules for simplifying block diagrams, block diagram implementations of canonical forms of state space models\n\n\n10\nSystem type, steady state error, and disturbance rejection  Reading: Nise Ch. 7\n\n\n11\nBode and Nyquist Plots\n\n\n12\nNyquist stability criterion, gain and phase margins\n\n\n13\nLead-Lag compensators\n\n\n\n\n\n\n\n\n\n\n\n\n\nWeek\nLab\n\n\n\n\n1\nNo Labs\n\n\n2\nLab 1 : Introduction to Matlab\n\n\n3\nLab 2 : Transfer functions and step response\n\n\n4\nLab 3 : System identification via Step Response\n\n\n5\nLab 4 : Eigenvalues and eigenvectors\n\n\n6\nLab 5 : State-Feedback Control (in simulation)\n\n\n7\nLab 6 : State-Feedback Control (in hardware)\n\n\n8\nLab 7 : Luenberger Observer for State Estimation\n\n\n9\nLab 8 : Output-Feedback Control\n\n\n10\nLab 9 : Block Diagram Reduction using Matlab\n\n\n11\nLab 10 : System identification via Bode Plots\n\n\n12\nLab 11 : Nyquist stability criterion\n\n\n13\nLab 12 : Lead-Lag compensator design\n\n\n\n\n\n\n\nTextbook\n\n\nN. Nise, Control Systems Engineering, 7th Ed., Wiley\nBoth paper and electronic versions of the textbook are available from the McGill bookstore. The electronic version of the book is also available from the publisher’s website and Google books.\n\n\n\n\nR.L. Williams II and D.A. Lawrence, Linear State‐Space Control Systems, Wiley.\nThe electronic version of the book is available the library.\n\n\nReference Books\n\n\nG.F. Franklin, J. Powell, A. Emani-Naeini, Feedback Control of Dynamical Systems, 7th Ed., Pearson.\nK. Oagata, Modern Control Engineering, 5th Ed., Pearson.\n\n\n\n\n\n\n\nAssignments (20%) Weekly homework assignments. Typically, each assignment will consist of four questions, out of which one or two randomly selected questions will be grader. The lowest two homework assignments will be dropped.\nLaboratory (20%) In-person weekly labs, to be conducted in groups of two. At the end of each lab, each group has to submit a lab report by filling in a Matlab Livescript template provided as part of the lab assignment.\nMid Term (20%) Closed book in-class exam. Oct 10 (during class time)\nFinal Exam (40%) Closed book, in-person exam. Will be scheduled by the exam office and the dates will be announced later.\nThe final exam will cover all the material seen in the class during the term.\n\n\n\n\n\nAssignments must be submitted electronically on myCourses as a PDF. You may write the assignments on paper and then scan them as a PDF (there are several such apps available for all phone platforms), or write on a tablet and convert to PDF, or type using a word processor.\nThere will no make-up examination for students who miss a mid-term.\n\nStudent who miss the exam due to a valid reason (see Faculty of Engineering policy) should notify the instructor within a week of the exam and provide necessary documentation.\nIf, and only if, proper documentation for a missed exam is presented, the marks for the missed exam will be shifted to the final exam.\nStudents who miss the mid-term exam for any other reason (e.g., no medical note, going to the exam at the wrong time, or on the wrong day, etc.) will get zero marks on the exam.\n\nAny request for reevaluation of a mid-term or an assignment must be made in writing within a week of its return. Note that requesting a re-grade will mean that you WHOLE assignment or exam will be re-graded.\nDue to paucity of grading hours, only one or two randomly selected questions will be graded in each assignment.\nThe lowest two assignments and labs will be dropped. There will be no make-up for missed assignments and labs, even if it is for a valid reason. The whole point of dropping the lowest two assignments/labs is to reduce the administrative overhead of keeping track of such missed assignments/labs.\n\n\nRight to submit in English or French written work that is to be graded.\n\nIn accord with McGill University’s Charter of Students’ Rights, students in this course have the right to submit in English or in French any written work that is to be graded.\n\nAcademic Integrity\n\nMcGill University values academic integrity. Therefore all students must understand the meaning and consequences of cheating, plagiarism and other academic offences under the Code of Student Conduct and Disciplinary Procedures (see McGill’s guide to academic honesty for more information).\nL’université McGill attache une haute importance à l’honnêteté académique. Il incombe par conséquent à tous les étudiants de comprendre ce que l’on entend par tricherie, plagiat et autres infractions académiques, ainsi que les conséquences que peuvent avoir de telles actions, selon le Code de conduite de l’étudiant et des procédures disciplinaires (pour de plus amples renseignements, veuillez consulter le guide pour l’honnêteté académique de McGill.)\n\n\n\n\n\nThe course is taught in a “chalk and board” style; there will be no power point presentations. All students are expected to attend lectures and take notes. Partial notes on some of the material will be provided, but are not a substitute for the material covered in class.\n© Instructor-generated course materials (e.g., handouts, notes, summaries, exam questions) are protected by law and may not be copied or distributed in any form or in any medium without explicit permission of the instructor. Note that infringements of copyright can be subject to follow up by the University under the Code of Student Conduct and Disciplinary Procedures.\n\n\n\n\nAs the instructor of this course I endeavor to provide an inclusive learning environment. However, if you experience barriers to learning in this course, do not hesitate to discuss them with me or contact the office of Student Accessibility and Achievement.\nEnd-of-course evaluations are one of the ways that McGill works towards maintaining and improving the quality of courses and the student’s learning experience. You will be notified by e-mail when the evaluations are available. Please note that a minimum number of responses must be received for results to be available to students."
  },
  {
    "objectID": "index.html#general-information",
    "href": "index.html#general-information",
    "title": "Course Outline",
    "section": "",
    "text": "Instructor\n\n\nAditya Mahajan\nOffice Hours: TBD\n\n\nTeaching Assistants\n\n\nTBD\n\n\nLectures\n\n\n10:05am–11:25am Tuesday, Thursday (ENGMC 11)\n\n\nTutorials\n\n\n8:35am–10:25am Friday, (ENGMC 11)\n\n\n\nEveryone must be registered for the tutorial. Tutorials start from the second week of classes.\n\nLabs\n\n\n1:35pm-3:25pm Monday (TR 4090)\n\n\n\n\n3:35pm–5:25pm Monday (TR 4090)\n\n\n\n\n1:35pm–3:25pm Tuesday (TR 4090)\n\n\n\n\n1:35pm–3:25pm Wednesday (TR 4090)\n\n\n\n\n1:35pm–3:25pm Friday (TR 4090)\n\n\n\nEveryone must be registered for one lab. Labs start from the second week of classes.\nThe labs have to be done in groups of two. The groups will be formed in the first week of classs.\n\nPrerequisites\n\n\nECSE 206 (Fundamentals of Signals and Systems)\nECSE 210 (Electrical Circuits 2)\n\n\nCommunication\n\nUse the discussion board on myCourses for all questions related to the course. Only personal emails related to medical exceptions for missing a deliverable will be answered."
  },
  {
    "objectID": "index.html#graduate-attributes-and-learning-outcomes",
    "href": "index.html#graduate-attributes-and-learning-outcomes",
    "title": "Course Outline",
    "section": "",
    "text": "Attribute\nDescription\nStatus\n\n\n\n\nKB\nKnowledge Base for Engineering\nDeveloped\n\n\nPA\nProblem Analysis\nDeveloped\n\n\nIN\nInvestigation\nDeveloped\n\n\nDE\nDesign\nIntroduced\n\n\n\nUpon the successful completion of this course, the student students will have demonstrated the ability to:\n\nApply time- and frequency-domain tools to analyze linear time-invariant systems (KB, PA)\nDesign controllers based on state-space methods and lead-lag compensators to meet time-response specifications (KB, PA, DE)\nUse Matlab to analyze and synthesize controllers for linear time-invariant systems (DE, IN)"
  },
  {
    "objectID": "index.html#course-content",
    "href": "index.html#course-content",
    "title": "Course Outline",
    "section": "",
    "text": "Week\nMaterial Covered\n\n\n\n\n1\nReview of LTI Systems and Laplace Transforms  Reading: Nise Ch. 2\n\n\n2\nState-space modeling, canoncial forms, transfer function of state space models  Reading: William and Lawrence Ch. 1 and Ch. 2\n\n\n3\nPole Zero Plot Step response of first and second order systems, dominant pole approximation  Reading: Nise Ch. 4\n\n\n4\nMatrix exponential and solution of matrix differential equations, time response of state space models\n\n\n5\nPole placement, controllability, and state feedback\n\n\n6\nLuenberger observer, observability, output feedback, and separation principle\n\n\n7\nReview and Mid-Term\n\n\n8\nRouth-Hurwitz stability criterion. Special cases: zero in first column, row of zeros.\n\n\n9\nBlock diagrams, rules for simplifying block diagrams, block diagram implementations of canonical forms of state space models\n\n\n10\nSystem type, steady state error, and disturbance rejection  Reading: Nise Ch. 7\n\n\n11\nBode and Nyquist Plots\n\n\n12\nNyquist stability criterion, gain and phase margins\n\n\n13\nLead-Lag compensators"
  },
  {
    "objectID": "index.html#lab-schedule",
    "href": "index.html#lab-schedule",
    "title": "Course Outline",
    "section": "",
    "text": "Week\nLab\n\n\n\n\n1\nNo Labs\n\n\n2\nLab 1 : Introduction to Matlab\n\n\n3\nLab 2 : Transfer functions and step response\n\n\n4\nLab 3 : System identification via Step Response\n\n\n5\nLab 4 : Eigenvalues and eigenvectors\n\n\n6\nLab 5 : State-Feedback Control (in simulation)\n\n\n7\nLab 6 : State-Feedback Control (in hardware)\n\n\n8\nLab 7 : Luenberger Observer for State Estimation\n\n\n9\nLab 8 : Output-Feedback Control\n\n\n10\nLab 9 : Block Diagram Reduction using Matlab\n\n\n11\nLab 10 : System identification via Bode Plots\n\n\n12\nLab 11 : Nyquist stability criterion\n\n\n13\nLab 12 : Lead-Lag compensator design"
  },
  {
    "objectID": "index.html#course-material",
    "href": "index.html#course-material",
    "title": "Course Outline",
    "section": "",
    "text": "Textbook\n\n\nN. Nise, Control Systems Engineering, 7th Ed., Wiley\nBoth paper and electronic versions of the textbook are available from the McGill bookstore. The electronic version of the book is also available from the publisher’s website and Google books.\n\n\n\n\nR.L. Williams II and D.A. Lawrence, Linear State‐Space Control Systems, Wiley.\nThe electronic version of the book is available the library.\n\n\nReference Books\n\n\nG.F. Franklin, J. Powell, A. Emani-Naeini, Feedback Control of Dynamical Systems, 7th Ed., Pearson.\nK. Oagata, Modern Control Engineering, 5th Ed., Pearson."
  },
  {
    "objectID": "index.html#evaluation",
    "href": "index.html#evaluation",
    "title": "Course Outline",
    "section": "",
    "text": "Assignments (20%) Weekly homework assignments. Typically, each assignment will consist of four questions, out of which one or two randomly selected questions will be grader. The lowest two homework assignments will be dropped.\nLaboratory (20%) In-person weekly labs, to be conducted in groups of two. At the end of each lab, each group has to submit a lab report by filling in a Matlab Livescript template provided as part of the lab assignment.\nMid Term (20%) Closed book in-class exam. Oct 10 (during class time)\nFinal Exam (40%) Closed book, in-person exam. Will be scheduled by the exam office and the dates will be announced later.\nThe final exam will cover all the material seen in the class during the term."
  },
  {
    "objectID": "index.html#marking-policy",
    "href": "index.html#marking-policy",
    "title": "Course Outline",
    "section": "",
    "text": "Assignments must be submitted electronically on myCourses as a PDF. You may write the assignments on paper and then scan them as a PDF (there are several such apps available for all phone platforms), or write on a tablet and convert to PDF, or type using a word processor.\nThere will no make-up examination for students who miss a mid-term.\n\nStudent who miss the exam due to a valid reason (see Faculty of Engineering policy) should notify the instructor within a week of the exam and provide necessary documentation.\nIf, and only if, proper documentation for a missed exam is presented, the marks for the missed exam will be shifted to the final exam.\nStudents who miss the mid-term exam for any other reason (e.g., no medical note, going to the exam at the wrong time, or on the wrong day, etc.) will get zero marks on the exam.\n\nAny request for reevaluation of a mid-term or an assignment must be made in writing within a week of its return. Note that requesting a re-grade will mean that you WHOLE assignment or exam will be re-graded.\nDue to paucity of grading hours, only one or two randomly selected questions will be graded in each assignment.\nThe lowest two assignments and labs will be dropped. There will be no make-up for missed assignments and labs, even if it is for a valid reason. The whole point of dropping the lowest two assignments/labs is to reduce the administrative overhead of keeping track of such missed assignments/labs.\n\n\nRight to submit in English or French written work that is to be graded.\n\nIn accord with McGill University’s Charter of Students’ Rights, students in this course have the right to submit in English or in French any written work that is to be graded.\n\nAcademic Integrity\n\nMcGill University values academic integrity. Therefore all students must understand the meaning and consequences of cheating, plagiarism and other academic offences under the Code of Student Conduct and Disciplinary Procedures (see McGill’s guide to academic honesty for more information).\nL’université McGill attache une haute importance à l’honnêteté académique. Il incombe par conséquent à tous les étudiants de comprendre ce que l’on entend par tricherie, plagiat et autres infractions académiques, ainsi que les conséquences que peuvent avoir de telles actions, selon le Code de conduite de l’étudiant et des procédures disciplinaires (pour de plus amples renseignements, veuillez consulter le guide pour l’honnêteté académique de McGill.)"
  },
  {
    "objectID": "index.html#course-delivery",
    "href": "index.html#course-delivery",
    "title": "Course Outline",
    "section": "",
    "text": "The course is taught in a “chalk and board” style; there will be no power point presentations. All students are expected to attend lectures and take notes. Partial notes on some of the material will be provided, but are not a substitute for the material covered in class.\n© Instructor-generated course materials (e.g., handouts, notes, summaries, exam questions) are protected by law and may not be copied or distributed in any form or in any medium without explicit permission of the instructor. Note that infringements of copyright can be subject to follow up by the University under the Code of Student Conduct and Disciplinary Procedures."
  },
  {
    "objectID": "index.html#additional-notes",
    "href": "index.html#additional-notes",
    "title": "Course Outline",
    "section": "",
    "text": "As the instructor of this course I endeavor to provide an inclusive learning environment. However, if you experience barriers to learning in this course, do not hesitate to discuss them with me or contact the office of Student Accessibility and Achievement.\nEnd-of-course evaluations are one of the ways that McGill works towards maintaining and improving the quality of courses and the student’s learning experience. You will be notified by e-mail when the evaluations are available. Please note that a minimum number of responses must be received for results to be available to students."
  },
  {
    "objectID": "step-response.html",
    "href": "step-response.html",
    "title": "Step Response",
    "section": "",
    "text": "In the previous lecture, we saw that we can use the pole zero plot to determine if a system is BIBO stability. We also saw that we can compute the step reponse using inverse LTs. In this lecture, we will develop a heuristic method to approximate the step response from a pole-zero plot."
  },
  {
    "objectID": "step-response.html#step-response-from-pole-zero-plot",
    "href": "step-response.html#step-response-from-pole-zero-plot",
    "title": "Step Response",
    "section": "1 Step response from pole-zero plot",
    "text": "1 Step response from pole-zero plot\nTo understand how to infer the step response from the pole-zero plot, let’s revisit the example from last lecture:\n\n\n\n\n\n\nFigure 1: Block diagram for a simple LTI system\n\n\n\nRecall that we simplified the partial fraction expansion as \\[ \\frac{\\frac12}{s} - \\frac{\\frac12}{s+2}.\\]\nConsequently, the step response (which is the inverse LT of the above) is: \\[\n\\Bigl[ \\underbrace{\\frac 12}_{\\text{Forced response}}\n-\n\\underbrace{\\frac 12 e^{-2t}}_{\\text{Natural response}}\n\\Bigr] \\mathbb{1}(t).\n\\]\nThe salient features of the step response are:\n\nThe pole of the input generates a forced response.\nThe pole of the system TF generates a natural response.\nThe amplitude of the response depends on the exact values of the poles and zeros, but the form of the response only depends on the location of the poles.\n\nThus, even without doing any exact partial fraction expansion, we know that \\[\n\\dfrac{1}{s(s+2)} = \\frac{K_1}{s} + \\frac{K_2}{s+2}.\n\\] Thus, we know that the output will be of the form: \\[\ny(t) = \\bigl[ K_1 + K_2 e^{-2t} \\bigr] \\mathbb{1}(t).\n\\]\nThus, we can obtain the form of the output without any explicit calculations.\n\nExercise 1 Find the general form of the step response of the following systems:\n\n\\(\\displaystyle\nG(s) = \\frac{ s + 2 } { (s+5)(s+10) }.\\)\n\\(\\displaystyle\nG(s) = \\frac{ 5(s+3)(s+10) }{ (s+1)(s+5)(s+20) }.\\)\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\\(y(t) = \\bigl[\nK_1 + K_2 e^{-5t} + K_3 e^{-10t}\n\\bigr] \\mathbb{1}(t).\\)\n\\(y(t) = \\bigl[\nK_1 + K_2 e^{-t} + K_3 e^{-5t}  + K_4 e^{-20t}\n\\bigr] \\mathbb{1}(t).\\)"
  },
  {
    "objectID": "step-response.html#dc-gain",
    "href": "step-response.html#dc-gain",
    "title": "Step Response",
    "section": "2 DC Gain",
    "text": "2 DC Gain\nIn the above examples, the system does not have a pole at origin. Such systems are called type 0 systems. For stable type 0 systems, the step response always settles to a steady state value known as the DC gain. For a type 0 system with TF \\(G(s)\\), the DC gain is given by \\[\n\\text{DC-gain} = G(0).\n\\]\nWe will expand more on this point later in the course."
  },
  {
    "objectID": "step-response.html#dominant-poles-and-approximate-system-response",
    "href": "step-response.html#dominant-poles-and-approximate-system-response",
    "title": "Step Response",
    "section": "3 Dominant poles and approximate system response",
    "text": "3 Dominant poles and approximate system response\nNow we compare the step response of two systems\n\n\\(G_1(s) = \\dfrac{1}{(s+2)}\\)\n\\(G_2(s) = \\dfrac{20}{(s+2)(s+20)}\\).\n\nNote that both systems are stable type 0 systems with a DC gain of \\(0.5\\). So, we expect them to settle at a steady state value of \\(0.5\\).\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2: Step response of \\(G_1(s)\\) and \\(G_2(s)\\).\n\n\n\n\nThe step responses of both systems are very close. Thus, we can approximate \\(G_2(s)\\) by \\(G_1(s)\\). Let’s look at the partial fraction expansion to see what is happening.\n\n\\(\\displaystyle\nY_1(s) = \\frac{1}{s(s+2)} = \\frac{0.5}{s} - \\frac{0.5}{s+2}.\\)\n\\(\\displaystyle\nY_2(s) = \\frac{20}{s(s+2)(s+20)}\n= \\frac{0.5}{s} - \\frac{0.55}{s+2} + \\frac{0.055}{s+20}.\\)\n\nNote that the first two terms of \\(Y_2(s)\\) are almost the same as \\(Y_1(s)\\). Why is the third term \\(0.055/(s+20)\\) negligible? The factor \\(0.055\\) is small, but that is not the main reason for the third term to be small. To see what is happening, let’s compute the inverse LTs:\n\n\\(y_1(t) = [ 0.5 - 0.5 e^{-2t} ] \\mathbb{1}(t).\\)\n\\(y_2(t) = [0.5 - 0.55 e^{-2t} + 0.055 e^{-20t}.\\)\n\nThe reason that we can ignore \\(0.55/(s+20)\\) is that \\(e^{-20t}\\) decays much faster than \\(e^{-2t}\\). In particular, at \\(t=1\\),\n\n\\(e^{-2t} \\approx 0.1353\\)\n\\(e^{-20t} \\approx 2.06 \\times 10^{-9}\\).\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: Decaying exponentials\n\n\n\n\nIn this example, we say that in system \\(G_2(s)\\) the pole at \\(p_1 = -2\\) dominates the pole at \\(p_2 = -20\\). In this course, we will follow the heuristic that pole \\(p_1\\) dominates pole \\(p_2\\) if \\[\\begin{equation}\\label{eq:dominant-pole}\n\\ABS{\\text{Re}(p_1)} \\ge\n\\frac 1{5} \\ABS{\\text{Re}(p_2)}.\n\\end{equation}\\]\nDominant pole approximation refers to the approximate system where the dominated poles are removed. In particular, to obtain a dominant pole approximation of a system with poles \\(\\{p_1, \\dots, p_n\\}\\), we split the poles into two sets \\(\\mathcal P_d = \\{p_1, \\dots, p_k\\}\\) and \\(\\mathcal P_r = \\{p_{k+1}, \\dots, p_n\\}\\) which has the following property: every pole \\(p_i\\) in \\(\\mathcal P_d\\) dominates every pole \\(p_j\\) in \\(\\mathcal P_r\\). Then, the dominant pole approximation ignores all the poles in the set \\(\\mathcal P_r\\).\n\nExample 1 Consider the system \\[\n  G_1(s) = \\frac{10}{(s+1)(s+2)(s+10)}.\n\\] In this case, the pole at \\(-10\\) is dominated by both poles \\(\\{-1,-2\\}\\). Thus, the pole at \\(-10\\) can be ignored and the simplified system is \\[\n  \\tilde G_1(s) = \\frac{1}{(s+1)(s+2)}.\n\\]\nNote: Note that we have picked the gain of \\(\\tilde G_1(s)\\) so that \\(G_1(s)\\) and \\(\\tilde G_1(s)\\) have the same DC gain.\nWe can confirm this result by comparing the step responses:\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 4: Step response of \\(G(s)\\) and \\(\\tilde G(s)\\) in Example 1\n\n\n\n\n\n\nExample 2 Consider the system \\[\n  G_2(s) = \\frac{10}{(s+1)(s+4)(s+10)}.\n\\] In this case, we cannot ignore any pole. Note that the pole at \\(-1\\) does not dominate the pole at \\(-4\\), and the pole at \\(-4\\) does not dominate the pole at \\(-10\\). Thus, we cannot partition the poles into two sets such that one set dominates the other. Thus, the above system cannot be simplied to \\[\n  \\tilde G_2(s) = \\frac{1}{(s+1)(s+4)}.\n\\] We can confirm this result by comparing the step responses:\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 5: Step response of \\(G(s)\\) and \\(\\tilde G(s)\\) in Example 2\n\n\n\n\n\nWait what? Why is Figure 4 a good approximation while Figure 5 is not? Both of them look equally good or bad. This example highlights that we have to be careful with interpretting the dominant pole approximation heuristic. It says that if \\(\\eqref{eq:dominant-pole}\\) is satisfied then we expect the approximate system to behave the same as the original system. If \\(\\eqref{eq:dominant-pole}\\) is not satisfied, then there might be instances where the approximate system is different from the original system. For example, let’s consider: \\[\n  G_1(s) = \\frac{10}{( (s+2)^2 + 4^2 )(s + 10) }\n  \\stackrel{?}{\\approx}\n  \\tilde G_1(s) = \\frac{1}{((s+2)^2 + 4^2)}\n\\] versus \\[\n  G_2(s) = \\frac{10}{( (s+4)^2 + 8^2 )(s + 10) }\n  \\stackrel{?}{\\approx}\n  \\tilde G_2(s) = \\frac{1}{((s+4)^2 + 8^2)}\n\\] The dominant pole approximation heuristic says that the first approximation should a good approximation while the second may not be. We plot the two step responses to evalaute:\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Checking the quality of approximations"
  },
  {
    "objectID": "step-response.html#high-level-system-design-idea",
    "href": "step-response.html#high-level-system-design-idea",
    "title": "Step Response",
    "section": "4 High-level system design idea",
    "text": "4 High-level system design idea\nIn the next few weeks, we will learn techniques to design system controllers so that we can place the poles of a closed loop system at any desired location. But how do we choose where we want to place the poles of the closed loop system?\nOf course, the first objective is to make sure that the closed loop system is stable. However, a practical design goes beyond stability. Suppose we are designing the cruise controller of a car and have an option of the following three controllers.\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Step responses of three different systems\n\n\n\n\nIt is clear from the above plots that the transient response of the system matters as well. For a higer order system, finding the relationship between the location of the poles and the transient response can be difficult. To circumvent this difficulty, our general design philosophy will be as follows:\n\nWe will first understand the relationship between the location of the poles and the transient behavior of a first and second order system.\nLater, when it comes to system design, we will place the poles of the closed loop system such that the dominant pole approximation of the system is equivalent to a second order system."
  },
  {
    "objectID": "step-response.html#time-response-of-first-order-systems",
    "href": "step-response.html#time-response-of-first-order-systems",
    "title": "Step Response",
    "section": "5 Time response of first order systems",
    "text": "5 Time response of first order systems\nA general first order system is of the form \\[\n\\dfrac{dy(t)}{dt} + a y(t) = b u(t).\n\\] By inspection, we know that the transfer function is \\[\n  \\frac{b}{s+a} = \\frac{b}{a} \\cdot \\frac{a}{s+a}\n  = K \\dfrac{a}{s+a}.\n\\]\n\n\n\n\n\n\nFigure 8: A general first order system\n\n\n\n\n\n\n\n\nviewof a_1 = Object.assign(Inputs.range([0.5, 2.5], {label: \"a\", step: 0.1, value: 1 }), {style: '--label-width:20px'})\n\nviewof K_1 = Object.assign(Inputs.range([0.5, 1.5], {label: \"K\", step: 0.1, value: 1 }), {style: '--label-width:20px'})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntransformed_first_order = first_order.map(d =&gt;({...d, output: d.output*K_1}))\n\nPZplot = function(zeros, poles, xdomain, ydomain) {\n  return Plot.plot({\n    grid: true,\n    x: { domain: xdomain},\n    y: { domain: ydomain},\n\n    marks: [\n      // Axes\n      Plot.ruleX([0]),\n      Plot.ruleY([0]),\n      // Data\n      Plot.dot(zeros, {x:\"σ\", y:\"jω\", r: 5}),\n      Plot.dot(poles, {x:\"σ\", y:\"jω\", symbol: \"times\", r: 5}),\n    ]\n  })\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPZplot(\n       [], \n       [ {σ: -a_1, jω: 0} ], \n       [-3, 3],\n       [-3, 3],\n      )\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 1.6] },\n  x: { domain: [0,5] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    // a_1 is still 64 bit float while a is 16 bit float. So we do a crude comparison for equality. \n    Plot.line(transformed_first_order.filter(d =&gt; Math.abs(d.a - a_1) &lt;= 0.01), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 9: Step response of a first order system for different values of the parameters\n\n\n\nWe can compute the step response by the usual partial fraction expansion: \\[ Y(s) = K \\frac{a}{s+a} = K \\biggl[ \\frac{1}{s} - \\frac{1}{s+a}\\biggr]. \\] Taking inverse LTs, we get: \\[ y(t) = K \\bigl[ 1 - e^{-at} \\bigr] \\mathbb{1}(t). \\]\n\n5.1 Important characteristics of the step response\nThe response of a first order system has the following features:\n\nThere is no overshoot\nThe initial slope (at \\(t=0\\)) is non-zero and equal to \\(a\\).\n\n\n5.1.1 Time constant \\(τ\\)\n\nThe parameter \\(τ = 1/a\\) is called the time constant of a first order system.\nThe intial slope of the step response is \\(a\\) (i.e., \\(1/τ\\)).\nAt \\(t=τ\\), \\(c(τ) = K(1-e^{-1}) \\approx 63\\%\\) of final value.\n\n\n\n5.1.2 Rise time \\(T_r\\)\n\nThe rise time, denoted by \\(T_r\\) is the time to go from \\(10\\%\\) to \\(90\\%\\) of the final value.\nTo find time \\(t_1\\) when the response reaches \\(10\\%\\) of the final value: \\[\n  c(t_1) = 1 - e^{-a t_1} = 0.1\n  \\implies\n  t_1 = \\frac{0.11}{a}.\n\\]\nSimilarly, to find time \\(t_2\\) when the response reaches \\(90\\%\\) of the final value: \\[\n  c(t_2) = 1 - e^{-a t_2} = 0.9\n  \\implies\n  t_2 = \\frac{2.31}{a}.\n\\]\nThus, \\[\n\\bbox[5pt,border: 1px solid]{T_r = \\frac{2.31}{a} - \\frac{0.11}{a} = \\frac{2.2}{a}}\n\\]\n\n\n\n5.1.3 Settling time \\(T_s\\)\n\nThe (2%) setting time is the time required for the step response to reach 2% of its final value.\nTo find \\(T_s\\), we solve \\[\n(1-e^{-a T_s}) = 0.98\n\\implies\n\\bbox[5pt,border: 1px solid]{T_s = \\frac 4a}\n\\]\n\n\nExample 3 Consider the TF \\(G(s) = \\dfrac{100}{s+50}\\). Identify the time constant \\(τ\\), rise time \\(T_r\\), and settling time \\(T_s\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe start by writing the TF in standard form: \\[\n  G(s) = 2 \\frac{50}{s+50}.\n\\] Comparing from the standard form, we have \\(K=2\\) and \\(a=50\\). Thus,\n\n\\(τ = \\dfrac{1}{a} = 0.02\\).\n\\(T_r = \\dfrac{2.2}{a} = 2.2 τ = 0.044\\) s.\n\\(T_s = \\dfrac{4}{a} = 4 τ = 0.08\\) s."
  },
  {
    "objectID": "step-response.html#identifying-a-first-order-system-via-testing",
    "href": "step-response.html#identifying-a-first-order-system-via-testing",
    "title": "Step Response",
    "section": "6 Identifying a first-order system via testing",
    "text": "6 Identifying a first-order system via testing\nIn many applications, we may not know the TF of a system and may need to identify the TF from the measurements of the step response. We will do such an experiment in Lab 3. In such cases, we can identify that the system is first order from the following features:\n\nno overshoot\nnon-zero initial slope.\n\nFor a first order system, we need to identify two parameters: \\(K\\) and \\(a\\).\n\nThe gain \\(K\\) is equal to the final value of the step response.\nTo identify \\(a\\), we identify the time constant \\(τ=1/a\\) as the time where the step response is \\(0.63K\\).\n\nThen, the TF is \\[ G(s) = K \\frac{a}{s+a}. \\]\n\nExample 4 Identify the transfer function from the following step response\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nSince there is no overshoot and the initial slope is non-zero, this is the step response of a first order system.\n\nThe final DC value of response is \\(2.5\\). Thus, \\(K = 2.5\\).\nNow we search for the time when the response is \\(0.63K = 1.575\\) which happens around \\(τ=0.25\\). Thus, \\(a = 1/τ = 4\\).\n\nHence \\(G(s) = K \\dfrac{a}{s+a} = \\dfrac{10}{s+4}\\)."
  },
  {
    "objectID": "step-response.html#types-of-second-order-systems",
    "href": "step-response.html#types-of-second-order-systems",
    "title": "Step Response",
    "section": "7 Types of second order systems",
    "text": "7 Types of second order systems\nA general second order system is of the form \\[\n\\frac{d^2 y(t)}{dt^2} + a_1 \\frac{d y(t)}{dt} + a_0 y(t) = b_0 u(t).\n\\] By inspection, we know that the transfer function is \\[\nG(s) = \\frac{b_0}{s^2 + a_1 s + a_0}\n=\nK \\frac{ω_n^2}{s^2 + 2 ζ ω_n s + ω_n^2}\n\\] where \\(K\\) is called the gain, \\(ω_n\\) is called the natural frequency and \\(ζ\\) is called the damping coefficient When \\(ζ &lt; 0\\), the system is unstable and we will not discuss that case. When \\(ζ \\ge 0\\), we observe four types of behavior depending on the value of \\(ζ\\). These are called the categories of a second order system:\n\nUndamped \\(ζ = 0\\), in which case the poles are at \\(\\pm j ω_n\\).\nUnderdamped \\(0 &lt; ζ &lt; 1\\), in which case the poles are at \\(-ω_n( ζ \\pm j\\sqrt{1 - ζ^2}).\\)\nCritically damped \\(ζ = 1\\), in which case there is a double pole at \\(-ω_n\\).\nOverdamped \\(ζ &gt; 1\\), in which case the poles are at \\(-ω_n(ζ \\pm \\sqrt{ζ^2 - 1}).\\)\n\nFigure 10 illustrates the impact of the damping coefficient on the location of the poles:\n\n\n\n\n\n\nviewof zeta_damping = Object.assign(Inputs.range([0, 5.5], {label: \"ζ\", step: 0.1, value: 0.5 }), {style: '--label-width:20px'})\n\n  ω_damping = 1\n\n  poles_damping = {\n    var factor\n    var poles\n\n    if (zeta_damping == 0) {\n      poles = [ { σ: 0, jω: ω_damping },\n                { σ: 0, jω: -ω_damping } ] \n    } else if (0 &lt; zeta_damping && zeta_damping &lt; 1) { \n      factor = Math.sqrt(1-zeta_damping*zeta_damping)\n      poles = [ { σ: -ω_damping*zeta_damping, jω: ω_damping*factor }, \n                { σ: -ω_damping*zeta_damping, jω: -ω_damping*factor } ] \n    } else {// zeta_damping &gt; 1\n      factor = Math.sqrt(zeta_damping*zeta_damping-1)\n      poles = [ { σ: -ω_damping*zeta_damping + ω_damping*factor, jω: 0 }, \n                { σ: -ω_damping*zeta_damping - ω_damping*factor, jω: 0 } ] \n    }\n    return poles\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPZplot(\n       [], \n       poles_damping,\n       [-4.5*ω_damping, 0.5*ω_damping],\n       [-1.5*ω_damping, 1.5*ω_damping],\n      )\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 1.6] },\n  x: { domain: [0,8] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    // zeta_damping is still 64 bit float while a is 16 bit float. So we do a crude comparison for equality. \n    Plot.line(second_order_zeta.filter(d =&gt; Math.abs(d.ζ - zeta_damping) &lt;= 0.01), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 10: Step response as a function of damping coefficient\n\n\n\n\nExercise 2 Indentify the category of the following second order systems:\n\n\\(\\dfrac{12}{s^2 + 8s + 12}.\\)\n\\(\\dfrac{16}{s^2 + 8s + 16}\\).\n\\(\\dfrac{20}{s^2 + 8s + 20}\\).\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n\\(ζ = \\dfrac{8}{2\\sqrt{12}} \\approx 1.1547\\). Thus, the system is overdamped.\n\\(ζ = \\dfrac{8}{2\\sqrt{16}} = 1\\). Thus, the system is critically damped.\n\\(ζ = \\dfrac{8}{2\\sqrt{20}} \\approx 0.8944\\). Thus, the system is underdamped."
  },
  {
    "objectID": "step-response.html#step-response-of-undamped-second-order-system",
    "href": "step-response.html#step-response-of-undamped-second-order-system",
    "title": "Step Response",
    "section": "8 Step response of undamped second order system",
    "text": "8 Step response of undamped second order system\nFor \\(ζ = 0\\), the TF is \\[\nG(s) = K \\frac{ω_n^2}{s^2 + ω_n^2}\n= K \\frac{ω_n^2}{ (s+j ω_n)(s - j ω_n) }.\n\\]\nThis would correspond to a LC circuit (without resistance) or a spring mass system (without damping). These are idealized models, so the step response is mainly for academic interest. Although we derive the step response below, we will not investigate the undamped system in this course.\nTo find the step response, we observe the following formula from the LT tables: \\[\n\\dfrac{a^2 + b^2}{s( (s+a)^2 + b^2 )}\n\\xleftrightarrow{\\quad \\mathcal L\\quad}\n\\biggl[ 1 - e^{-at}\\bigg( \\cos bt + \\frac{a}{b}\\sin bt \\biggr) \\biggr].\n\\IND(t)\n\\]\nChoosing \\(a = 0\\) and \\(b = ω_n\\), we get \\[\nK \\frac{1}{s} \\cdot \\frac{ω_n^2}{s^2 + ω_n^2}\n\\xleftrightarrow{\\quad \\mathcal L\\quad}\nK [1 - \\cos ω_n t] \\IND(t).\n\\]\n\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 2.2] },\n  x: { domain: [0,8] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    Plot.line(second_order_zeta.filter(d =&gt; Math.abs(d.ζ - 0) &lt;= 0.01), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n  ]\n})\n\n\n\n\n\n\n\n\nFigure 11: Step response of undamped system"
  },
  {
    "objectID": "step-response.html#step-response-of-underdamped-second-order-system",
    "href": "step-response.html#step-response-of-underdamped-second-order-system",
    "title": "Step Response",
    "section": "9 Step response of underdamped second order system",
    "text": "9 Step response of underdamped second order system\nFor the case when \\(0 &lt; ζ &lt; 1\\), we can write the TF as \\[\nG(s) = \\frac{ω_n^2}{s^2 + 2 ζ ω_n s + ω_n^2}\n=\n\\frac{σ^2 + ω_d^2}{(s+σ)^2 + ω_d^2}\n\\] where \\(σ = ζ ω_n\\) and \\(ω_d = \\sqrt{1 - ζ^2} ω_n\\). Note that we have \\[ σ^2 + ω_d^2 = ω_n.\\] The parameter \\(ω_n\\) is called the natural frequency. It is the frequency at which the system will oscillate when there is no damping. The parameter \\(ω_d\\) is called the damped frequency. As we will show below, it is the frequency at which the damped system oscillates.\nThe system has two complex conjugate roots. In cartesian coordinates, these roots are at \\(-σ \\pm j ω_d\\), while in polar coordinates they are at \\(ω_n e^{\\pm j(π/2 + φ)}\\), where \\(\\phi = \\sin^{-1}ζ\\).\nTo find the step response, we again recall the following LT formula from the LT tables: \\[\n\\dfrac{a^2 + b^2}{s( (s+a)^2 + b^2 )}\n\\xleftrightarrow{\\quad \\mathcal L\\quad}\n\\biggl[ 1 - e^{-at}\\bigg( \\cos bt + \\frac{a}{b}\\sin bt \\biggr) \\biggr].\n\\IND(t)\n\\] Taking \\(a = σ\\) and \\(b = ω_d\\), we get that the step response is \\[\\begin{align*}\ny(t) &= K \\biggl[ 1 - e^{-σt} \\biggl(\\cos ω_d t + \\frac{σ}{ω_d} \\sin ω_d t\\biggr)\\biggr] \\IND(t) \\\\\n&= K \\biggl[ 1 - \\frac{1}{\\sqrt{1 - ζ^2}} e^{-σ t} \\cos(ω_dt - \\phi) \\biggr] \\IND(t)\n\\end{align*}\\] where as before \\(φ = \\sin^{-1} ζ\\).\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 12: Step response of underdamped system for \\(ζ = 0.5\\)\n\n\n\n\n\n9.1 Important characteristics of the step response\nThe response of an underdamped second order system has the following features:\n\nThe initial slope (at \\(t=0\\)) is zero.\nThe output oscillates at frequency \\(ω_d\\). It overshoots and then settles back to the final DC value of \\(K\\).\nThe maximum peak, denoted by \\(M_p\\) is the maximum value of the step response.\nRather than working with maximum peak, we often use percentage overshoot which is defined as \\[\\% {\\rm OS} = \\frac{M_p - K}{K} × 100\\] which does not depend on the gain \\(K\\). We will show that \\[\n\\bbox[5pt,border: 1px solid]\n{\\% {\\rm OS} = e^{-π ζ/\\sqrt{1 - ζ^2}} × 100\n= e^{-π σ/ω_d} × 100}\n\\] where the last equality uses the fact that \\(ζ/\\sqrt{1-ζ^2} = σ/ω_d\\). We often use this relationship in the reverse, i.e., \\[\nζ = \\frac{- \\ln(\\%{\\rm OS}/100)}{\\sqrt{π^2 + \\ln^2(\\%{\\rm OS}/100)}}.\n\\]\nThe time needed to reach the maximum overshoot is called peak time and denoted by \\(T_p\\). We will show that \\[\n\\bbox[5pt,border: 1px solid]\n{T_p = \\frac{π}{ω_d} = \\frac{π}{ω_n \\sqrt{1 - ζ^2}}}\n\\]\nThe time after which the system stays within \\(Δ\\%\\) of the final value is called the \\(Δ\\%\\) settling time and denoted by \\(T_s(Δ\\%)\\). We will show that\n\n\\(T_s(1\\%) = \\dfrac{4.6}{σ}\\)\n\\(T_s(2\\%) = \\dfrac{4}{σ}\\)\n\\(T_s(5\\%) = \\frac{3}{σ}\\).\n\nThe time required for the response to go from \\(0.1\\) of the final value to \\(0.9\\) of the final value is called rise time and denoted by \\(T_r\\). It is difficult to get a closed form expression for \\(T_r\\). It can be verified numerically that \\(ω_n T_r\\) is approximately a constant that depends on \\(ζ\\). So we approximately compute \\(T_r\\) from a look-up table using interpolation:\n\n\n\nTable 1: \\(ω_n T_r\\) as a function of \\(ζ\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(ζ\\)\n0.1\n0.2\n0.3\n0.4\n0.5\n0.6\n0.7\n0.8\n0.9\n\n\n\n\n\\(ω_n T_r\\)\n1.104\n1.203\n1.321\n1.463\n1.638\n1.854\n2.216\n2.467\n2.883\n\n\n\n\n\n\n\n\n\nExample 5 Consider the TF \\[ G(s) = \\frac{100}{s^2 + 15s + 100}. \\] Find \\(T_p\\), \\(\\%{\\rm OS}\\), \\(T_s(2\\%)\\), and \\(T_r\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFrom inspection, we get that \\(ω_n^2 = 100\\) and \\(2 ζ ω_n = 15\\). Thus, \\(ω_n = 10\\) and \\(ζ  = 0.75\\). Then we have\n\n\\(T_p = \\dfrac{π}{ω_d} = 0.475\\).\n\\(\\%{\\rm OS} = \\exp\\biggl(\\dfrac{π σ}{ω_d}\\biggr) × 100 = 2.28\\%\\).\n\\(T_s(2\\%) = \\dfrac{4}{σ} = 0.533\\) sec.\nFrom Table 1, we get that for \\(ζ = 0.75\\), \\(ω_n T_r \\approx (2.216 + 2.467)/2 = 2.3415\\). Thus, \\(T_r = 2.3415/ω_n = 0.23415\\) sec."
  },
  {
    "objectID": "step-response.html#features-of-time-response-in-terms-of-location-of-poles",
    "href": "step-response.html#features-of-time-response-in-terms-of-location-of-poles",
    "title": "Step Response",
    "section": "10 Features of time response in terms of location of poles",
    "text": "10 Features of time response in terms of location of poles\n\n10.1 Same damped frequency\nThe peak time depends on the damped frequency. So, if we change \\(σ\\) while keeping \\(ω_d\\) fixed, the peak time of the system remains the same.\n\n\n\n\n\nviewof param_sigma = Object.assign(Inputs.range([0.1,4], {label: \"σ\", step: 0.1, value: 2 }), {style: '--label-width:20px'})\n\nω_d_sigma = 2\nT_p_sigma = Math.PI/ω_d_sigma\nM_p_sigma = 1 + Math.exp(-param_sigma*T_p_sigma)\npeak_sigma = [ {x: T_p_sigma, y: 0}, {x: T_p_sigma, y: M_p_sigma} ]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPZplot(\n       [], \n       [ {σ: -param_sigma, jω: ω_d_sigma}, {σ: -param_sigma, jω: -ω_d_sigma} ], \n       [-3, 3],\n       [-5, 5],\n      )\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 1.6] },\n  x: { domain: [0,5] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    // param_sigma is still 64 bit float while a is 16 bit float. So we do a crude comparison for equality. \n    Plot.line(second_order_sigma.filter(d =&gt; Math.abs(d.σ - param_sigma) &lt;= 0.01), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n    Plot.dot([ [T_p_sigma, M_p_sigma] ], {fill: \"red\", r:4}),\n    Plot.line(peak_sigma, {x: \"x\", y: \"y\", stroke: \"red\"})\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 13: Step response of a second order system for fixed \\(ω_d\\) and different values \\(σ\\).\n\n\n\n\n\n10.2 Same \\(σ\\)\nThe settling time depends on \\(σ\\). So, if we change \\(ω_d\\) while keeping \\(σ\\) fixed, the settling time of the system remains the same.\n\n\n\n\n\nviewof param_ωd = Object.assign(Inputs.range([0.1,4], {label: \"ωd\", step: 0.1, value: 2 }), {style: '--label-width:20px'})\n\nσ_ωd = 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPZplot(\n       [], \n       [ {σ: -σ_ωd, jω: param_ωd}, {σ: -σ_ωd, jω: -param_ωd} ], \n       [-3, 3],\n       [-5, 5],\n      )\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 1.6] },\n  x: { domain: [0,5] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    // param_ωd is still 64 bit float while a is 16 bit float. So we do a crude comparison for equality. \n    Plot.line(second_order_ωd.filter(d =&gt; Math.abs(d.ωd - param_ωd) &lt;= 0.01), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 14: Step response of a second order system for fixed \\(ζ\\) and different values \\(ω_n\\).\n\n\n\n\n\n10.3 Same damping coefficient\nThe peak overshoot depends on the damping coefficient. So, if we change \\(ω_n\\) keeping \\(ζ\\) constant, the peak overshoot (and therefore percentage overshoot) remains the same.\n\n\n\n\n\nviewof param_ωn = Object.assign(Inputs.range([0.1,4], {label: \"ωn\", step: 0.1, value: 2 }), {style: '--label-width:20px'})\n\nζ_ωn = 0.4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPZplot(\n       [], \n       [ {σ: -param_ωn*ζ_ωn, jω:  param_ωn*Math.sqrt(1 - ζ_ωn**2) },\n         {σ: -param_ωn*ζ_ωn, jω: -param_ωn*Math.sqrt(1 - ζ_ωn**2) } ],\n       [-3, 3],\n       [-5, 5],\n      )\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 1.6] },\n  x: { domain: [0,5] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    // param_ωn is still 64 bit float while a is 16 bit float. So we do a crude comparison for equality. \n    Plot.line(second_order_ωn.filter(d =&gt; Math.abs(d.ωn - param_ωn) &lt;= 0.01), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 15: Step response of a second order system for fixed \\(ω_d\\) and different values \\(σ\\). The red dot shows the peak of the step response."
  },
  {
    "objectID": "step-response.html#identifying-an-underdamped-second-order-system-via-testing",
    "href": "step-response.html#identifying-an-underdamped-second-order-system-via-testing",
    "title": "Step Response",
    "section": "11 Identifying an underdamped second order system via testing",
    "text": "11 Identifying an underdamped second order system via testing\nA second order underdamped system has two characteristics:\n\nOscillatory overshoots (can be hard to see for \\(ζ\\) close to 1)\nZero initial slope.\n\nNote that all underdamped higher order systems share these characteristics, so it can be sometimes hard to distinguish a second order system from a higher order system.\nFor a second order system, we need to identify three parameters: \\(K\\), \\(ω_n\\) and \\(ζ\\).\n\nThe gain \\(K\\) is equal to the final value of the step response.\nTo find \\(ω_n\\) and \\(ζ\\), we need to find two out the three features: peak time, percentage overshoot, and setting time. Using these features, we can identify \\(ω_n\\) and \\(ζ\\).\n\nThen, the TF is given by \\[ G(s) = K \\frac{ω_n^2}{s^2 + 2 ζ ω_n s + ω_n^2}. \\]\n\nExample 6 Identify the transfer function from the following step response\n\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFrom the step response, we can infer that this is the step response of an underdapmper second order system, which in general is of the form: \\[\n  G(s) = K \\frac{ω_n^2}{s^2 + 2 ζ ω_n s + ω_n^2}.\n\\]\nWe now identify the parameters:\n\nThe final DC value of the response is \\(2\\). Thus, \\(K = 2\\).\nFrom the plot, we see that \\(T_p \\approx 0.75\\). Thus, \\[ ω_d = \\frac{π}{T_p} = 4.188. \\]\nFrom the plot, we see that \\(y_{\\text{max}} = 2.4\\). We have already identified that \\(y_{\\text{final}} = 2\\). Thus, \\[ \\% {\\rm OS} = \\frac{y_{\\text{max}} - y_{\\text{final}}}{y_{\\text{final}}} \\times 100\n= 20\\%\n\\] The formula for \\(\\%{\\rm OS}\\) can be written as \\[\n\\%{\\rm OS} = \\exp(-σ T_p) \\times 100\n\\]\nInverting the formula, we get \\[\nσ = \\frac{-\\ln(\\%{\\rm OS}/100)}{T_p} = 2.146\n\\]\nThus, \\[ ω_n^2 = σ^2 + ω_d^2 = 22.151 \\]\n\nHence, the transfer function is \\[\nG(s) = 2 \\frac{22.151}{s^2 + 4.21s + 22.151}\n= \\frac{44.302}{s^2 + 4.21s + 22.151}.\n\\]\nTo confirm, we plot the step response of the above system below. The plotted response is almost identical to the given response.\n\nusing ControlSystems, Plots\n\nG = tf([44.302],[1,4.21,22.151])\n\nT = 6 \n\nplt = plot(size=(600,300), gridalpha=0.75, minorgridalpha=0.25)\nplot!(plt, step(G, T))"
  },
  {
    "objectID": "step-response.html#impact-of-zeros",
    "href": "step-response.html#impact-of-zeros",
    "title": "Step Response",
    "section": "12 Impact of zeros",
    "text": "12 Impact of zeros\nIn the characterization of the step response of a second order underdamped system above, we assumed that the system had no zeros. The presence of a zero leads to more oscillations and the exact behavior depends on whether the zero is in the left-hand place (called minimum phase system) or right-hand plane (called non-minimum phase system), which we discuss below.\nThe impact of zeros means that we will not be able to execute our high-level idea of controller design because we cannot control the zeros of a closed loop system. So, in practice, we need to verify the control design via simulations to make sure that the specs are satisfied.\n\n12.1 Impact of zero in the left-hand plane (minimum-phase system)\nTo undersand this, we compare the response of two systems \\[\n  \\dfrac{8}{s^2 + 4s + 8}\n  \\quad\\hbox{vs}\\quad\n  8 \\cdot \\dfrac{1+\\frac{s}{z}}{s^2 + 4s + 8}\n\\]\n\n\n\n\n\n\nviewof zero = Object.assign(Inputs.range([1,6], {label: \"z\", step: 1, value: 1 }), {style: '--label-width:20px'})\n\n\n\n\n\n\nPZplot(\n       [ {σ: -zero, jω: 0} ], \n       [ {σ: -2, jω: 2}, {σ: -2, jω: -2} ],\n       [-6, 2],\n       [-3, 3],\n      )\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 1.8] },\n  x: { domain: [0,5] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    Plot.line(second_order_min_zero.filter(d =&gt; d.z == zero), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n    Plot.line(second_order_min_zero.filter(d =&gt; d.z == 0), \n              {x:\"time\", y:\"output\", stroke: \"orange\" })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 16: Step response of a seocnd order system for different values zero. The orange curve shows the step response of a system without zero and the blue curve shows the step response of the system with zeros.\n\n\n\nThe above example shows that the presence of a zero in the LHP leads to more overshoot and as the zero moves away from the dominant pole, the response approaches that of a system with no zeros. To understand why this is the case, we can view the system as \\[\n  G(s) = K \\frac{ω_n^2 (1 + \\frac{s}{z})}{s^2 + 2 ζω_n^2 + ω_n^2}\n  =\n  K \\frac{ω_n^2}{s^2 + 2 ζω_n^2 + ω_n^2}\n  +\n  K \\frac{ω_n^2}{s^2 + 2 ζω_n^2 + ω_n^2} \\cdot \\frac{s}{z}\n  \\eqqcolon\n  G_1(s) + G_1(s) \\frac{s}{z}\n\\] where \\(G_1(s)\\) is the standard second-order system without a zero. Thus, the step response of the system is \\[\n  Y(s) = U(s) G(s)\n  =\n  U(s) G_1(s) + U(s) G_1(s) \\frac{s}{z}\n  =\n  Y_1(s) + Y_1(s) \\frac{s}{z}\n\\] where \\(Y_1(s)\\) is the step response of the TF with no zeros. Hence, \\[\n  y(t) = y_1(t) + \\frac{1}{z} \\frac{dy_1(t)}{dt}.\n\\] Since \\(y_1(t)\\) is increasing for small \\(t\\), the derivative \\(dy_1(t)/dt\\) is positive and therefore the second term leads to a faster and larger overshoot.\nThe above formula also shows that when \\(z\\) is large, then \\(y(t) \\approx y_1(t)\\).\n\n\n12.2 Impact of zero in the right-hand plane (non-minimum-phase system)\nTo understand this, we compare the response of two systems \\[\n  \\dfrac{8}{s^2 + 4s + 8}\n  \\quad\\hbox{vs}\\quad\n  8 \\cdot \\dfrac{1-\\frac{s}{z}}{s^2 + 4s + 8}\n\\]\n\n\n\n\n\n\nviewof zero_non_min = Object.assign(Inputs.range([1,6], {label: \"z\", step: 1, value: 1 }), {style: '--label-width:20px'})\n\n\n\n\n\n\nPZplot(\n       [ {σ: zero_non_min, jω: 0} ], \n       [ {σ: -2, jω: 2}, {σ: -2, jω: -2} ],\n       [-3, 6.5],\n       [-3, 3],\n      )\nPlot.plot({\n  grid: true,\n  y: { domain: [-1.6, 1.2] },\n  x: { domain: [0,5] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    Plot.line(second_order_non_min_zero.filter(d =&gt; d.z == zero_non_min), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n    Plot.line(second_order_non_min_zero.filter(d =&gt; d.z == 0), \n              {x:\"time\", y:\"output\", stroke: \"orange\" })\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nFigure 17: Step response of a seocnd order system for different values zero. The orange curve shows the step response of a system without zero and the blue curve shows the step response of the system with zeros.\n\n\n\nThe above example shows that a zero in the RHP leads to undershoot and as the zero moves to infinity, the response approaches that of a system with no zeros.\nTo understand why this is the case, we can follow the same analysis as for the minimal phase system to conclude that \\[\n  y(t) = y_1(t) - \\frac{1}{z} \\frac{dy_1(t)}{dt}.\n\\] Since \\(y_1(t)\\) is increasing for small \\(t\\), the derivative \\(dy_1(t)/dt\\) is positive and therefore the second term leads to an undershoot. The above formula also shows that when \\(z\\) is large, then \\(y(t) \\approx y_1(t)\\)."
  },
  {
    "objectID": "step-response.html#step-response-of-critically-damped-second-order-system",
    "href": "step-response.html#step-response-of-critically-damped-second-order-system",
    "title": "Step Response",
    "section": "13 Step response of critically damped second order system",
    "text": "13 Step response of critically damped second order system\nFor \\(ζ = 1\\), the TF is given by \\[ G(s) = \\frac{ω_n^2}{(s+ω_n)^2}. \\] From the LT tables, we get that \\[ y(t) = [ 1 - e^{-ω_n t}(1 + ω_n t) ] \\IND(t). \\]\nCritically damped systems have the fastest settling time among all second order system. The response can be visually differentiated from that of a second order system by noticing that the initial slope (at \\(t=0\\)) is zero.\n\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 1.3] },\n  x: { domain: [0,8] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    Plot.line(second_order_zeta.filter(d =&gt; Math.abs(d.ζ - 1) &lt;= 0.01), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n  ]\n})\n\n\n\n\n\n\n\n\nFigure 18: Step response of critically system for \\(ζ = 1.0\\)."
  },
  {
    "objectID": "step-response.html#step-response-of-overdamped-second-order-system",
    "href": "step-response.html#step-response-of-overdamped-second-order-system",
    "title": "Step Response",
    "section": "14 Step response of overdamped second order system",
    "text": "14 Step response of overdamped second order system\nFor \\(ζ &gt; 1\\), the system has two poles at \\[\np_1 = ω_n(ζ + \\sqrt{ζ^2 - 1)\n\\quad\\text{and}\\quad\np_2 = ω_n(ζ - \\sqrt{ζ^2 - 1).\n\\]\nThe TF can be written as \\[ G(s) = \\frac{ω_n^2}{(s+p_1)(s+p_2)}.\\]\nUsing partial fraction expansion, we can show that \\[\nY(s) = \\frac{1}{s}\\cdot G(s)\n= \\frac{1}{s} - \\frac{ω_n^2}{2 (p_1 - p_2) \\biggl[ \\frac{1/p_1}{s+p_1} + \\frac{1/p_2}{s+p_2} \\biggr].\n\\] Therefore, \\[\ny(t) = \\biggl[ 1 - \\frac{ω_n^2}{2\\sqrt{ζ^2 - 1}} \\biggl( \\frac{1}{p_1} e^{-p_1t} + \\frac{1}{p_2} e^{-p_2t} \\biggr) \\biggr] \\IND(t).\n\\]\n\nPlot.plot({\n  grid: true,\n  y: { domain: [0, 1.3] },\n  x: { domain: [0,8] },\n  marks: [\n    // Axes\n    Plot.ruleX([0]),\n    Plot.ruleY([0]),\n    // Data\n    Plot.line(second_order_zeta.filter(d =&gt; Math.abs(d.ζ - 1.5) &lt;= 0.01), \n              {x:\"time\", y:\"output\", stroke: \"darkblue\" }),\n  ]\n})\n\n\n\n\n\n\n\n\nFigure 19: Step response of overdamped system for \\(ζ = 1.5\\)."
  },
  {
    "objectID": "steady-state-errors.html",
    "href": "steady-state-errors.html",
    "title": "Steady-state errors",
    "section": "",
    "text": "So far, we have investigated system stability and transient response. We now look at steady-state error.\nSteady-state error is the difference between the input (or reference) and the output for a prescribed test input as \\(t \\to ∞\\). We are typically interested in the following test signals shown below:\nSignalPlot = function(points, xdomain, ydomain) {\n  return Plot.plot({\n    grid: true,\n    x: { domain: xdomain},\n    y: { domain: ydomain},\n\n    marks: [\n      // Axes\n      Plot.ruleX([0]),\n      Plot.ruleY([0]),\n      // Data\n      Plot.line(points, {x: \"x\", y: \"y\"}),\n    ]\n  })\n}\n\nparabola_points = {\n  var points = new Array()\n  var idx = 0;\n  points[idx++] = { x: -1, y: 0}\n  var Δ = 0.1;\n  for(var n=0; n &lt;= 40; n++) {\n    points[idx++] = { x: n*Δ, y : 0.5*(n*Δ)**3 }\n  }\n  return points\n}\nSince we are interested in steady state errors, we restrict attention to stable systems. The formulas that we derive will not be applicable to unstable systems."
  },
  {
    "objectID": "steady-state-errors.html#steady-state-errors-for-general-systems",
    "href": "steady-state-errors.html#steady-state-errors-for-general-systems",
    "title": "Steady-state errors",
    "section": "1 Steady-state errors for general systems",
    "text": "1 Steady-state errors for general systems\n\n\n\n\n\n\nFigure 2: An open loop system\n\n\n\nConsider a system with input \\(r(t)\\), TF \\(T(s)\\) and output \\(y(t)\\). The steady state error is defined as the difference between the reference and the ouput, i.e., \\[\n  e(t) = r(t) - y(t).\n\\] We assume that \\(T(s)\\) is stable. Therefore, from the final value theorem, we have \\[\ne(∞) = \\lim_{t \\to ∞} e(t) = \\lim_{s \\to 0} s E(s)\n\\] Now observe that \\[\nE(s) = R(s) - Y(s) = R(s) - R(s)T(s) = R(s)\\bigl[ 1 - T(s) \\bigr].\n\\] Hence, \\[\n\\bbox[5pt,border: 1px solid]\n{e(∞) = \\lim_{s \\to 0} s R(s) (1 - T(s))}\n\\]\n\nExercise 1 Find the steady-state error of the open loop system with TF \\[\nT(s) = \\frac{2s + 10}{s^2 + 3s + 15}.\n\\] to a step input.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe first check if the open loop system is stable. From Routh Hurwitz criteria we have\n\n\n\n1\n15\n\n\n3\n\n\n\n44/3\n\n\n\n\nSince all entries in the first column are positive, the system is stable. Therefore, we have \\[\n  e(∞) = \\lim_{s \\to 0} s R(s) (1 - T(s))\n  = 1 - T(0)\n  = \\frac{5}{15} = 0.333\n\\]\nTo confirm, we plot the step response of the above system below. From the step response, we see that the system settles around \\(0.67\\). Thus, the steady-state error is indeed \\(0.33\\) as computed.\n\nusing ControlSystems, Plots\n\nG = tf([2,10],[1,3,15])\n\nplt = plot(size=(600,300), gridalpha=0.75, minorgridalpha=0.25)\nplot!(plt, step(G))"
  },
  {
    "objectID": "steady-state-errors.html#system-type",
    "href": "steady-state-errors.html#system-type",
    "title": "Steady-state errors",
    "section": "2 System Type",
    "text": "2 System Type\nBefore looking at more general systems, we discuss the notion of a system type. A general TF can be written as \\[\n\\def\\1#1{\\Bigl(1 + \\dfrac{s}{#1}\\Bigr)}\nG(s) = K \\frac{\\1{z_1}\\1{z_2}\\cdots\\1{z_m}}\n      {\\textcolor{red}{s^k}\\1{p_1}\\1{p_2}\\cdots\\1{p_n}}\n\\] Here \\(k\\) denotes the number of poles at origin and is called the type of the system. Thus, we have\n\nType 0: \\(\\def\\1#1{\\Bigl(1 + \\dfrac{s}{#1}\\Bigr)}\n\\quad\nG(s) = K_p \\frac{\\1{z_1}\\1{z_2}\\cdots\\1{z_m}}\n    {\\1{p_1}\\1{p_2}\\cdots\\1{p_n}}\\)\nType 1: \\(\\def\\1#1{\\Bigl(1 + \\dfrac{s}{#1}\\Bigr)}\n\\quad\nG(s) = K_v \\frac{\\1{z_1}\\1{z_2}\\cdots\\1{z_m}}\n    {\\1{p_1}\\1{p_2}\\cdots\\1{p_n}}\\)\nType 2: \\(\\def\\1#1{\\Bigl(1 + \\dfrac{s}{#1}\\Bigr)}\n\\quad\nG(s) = K_a \\frac{\\1{z_1}\\1{z_2}\\cdots\\1{z_m}}\n    {\\1{p_1}\\1{p_2}\\cdots\\1{p_n}}\\)\n\nFor historical reasons, the gain corresponding to the different system types are called:\n\nposition constant \\(K_p = \\lim_{s \\to 0} G(s)\\)\nvelocity constant \\(K_v = \\lim_{s \\to 0} s G(s)\\)\nacceleration constant \\(K_a = \\lim_{s \\to 0}s^2 G(s)\\)\n\nNote that we have the following\n\n\n\nType\n\\(K_p\\)\n\\(K_v\\)\n\\(K_a\\)\n\n\n\n\n0\nfinite\n0\n0\n\n\n1\n\\(∞\\)\nfinite\n0\n\n\n2\n\\(∞\\)\n\\(∞\\)\nfinite\n\n\n\nThese constants play an important role in understanding the steady-state error for unity feedback systems, as explained below."
  },
  {
    "objectID": "steady-state-errors.html#steady-state-errors-for-unity-feedback-systems",
    "href": "steady-state-errors.html#steady-state-errors-for-unity-feedback-systems",
    "title": "Steady-state errors",
    "section": "3 Steady-state errors for unity feedback systems",
    "text": "3 Steady-state errors for unity feedback systems\n\n\n\n\n\n\nFigure 3: A unity feedback system\n\n\n\nConsider a unity feedback system as shown in Figure 3. The closed loop transfer function is given by \\[\nT(s) = \\frac{G(s)}{1 + G(s)} \\]\nThus, from the previous formula we get\n\\[\n\\bbox[5pt,border: 1px solid]\n{e(∞) = \\lim_{s \\to 0} s R(s)(1 - T(s))\n= \\lim_{s \\to 0} \\frac{s R(s)}{1 + G(s)}}\n\\] Note that this formula is valid only if the closed loop system \\(G(s)/(1 + G(s))\\) is stable.\nNow, we specialize this expression for the three test signals described before.\n\n3.1 Step Input\nConsider the steady-state error to step input for which \\(R(s) = 1/s\\). Thus, \\[\ne_{\\rm step}(∞) = \\lim_{s \\to ∞} \\frac{s R(s)}{1 + G(s)}\n= \\frac{1}{1 + \\lim_{s \\to 0} G(s)} = \\frac{1}{1 + K_p}.\n\\]\nTherefore, we have the following:\n\n\n\nType\n\\(K_p\\)\n\\(e_{\\rm step}(∞)\\)\n\n\n\n\n0\nfinite\n\\(\\dfrac{1}{1 + K_p}\\)\n\n\n1\n\\(∞\\)\n0\n\n\n2\n\\(∞\\)\n0\n\n\n\n\n\n3.2 Ramp input\nNow consider the steady-state error to ramp input for which \\(R(s) = 1/s^2\\). Thus, \\[\ne_{\\rm ramp}(∞) = \\lim_{s \\to 0} \\frac{s R(s)}{1 + G(s)}\n= \\frac{1}{\\lim_{s \\to 0} s G(s)} = \\frac{1}{K_v}.\n\\]\nTherefore, we have the following:\n\n\n\nType\n\\(K_v\\)\n\\(e_{\\rm ramp}(∞)\\)\n\n\n\n\n0\n0\n\\(∞\\)\n\n\n1\nfinite\n\\(\\dfrac{1}{K_v}\\)\n\n\n2\n\\(∞\\)\n0\n\n\n\n\n\n3.3 Parabola input\nNow consider the steady-state error to parabola input for which \\(R(s) = 1/s^3\\). Thus, \\[\ne_{\\rm para}(∞) = \\lim_{s \\to 0} \\frac{s R(s)}{1 + G(s)}\n= \\frac{1}{\\lim_{s \\to 0} s^2 G(s)} = \\frac{1}{K_a}.\n\\]\nTherefore, we have the following:\n\n\n\nType\n\\(K_a\\)\n\\(e_{\\rm para}(∞)\\)\n\n\n\n\n0\n0\n\\(∞\\)\n\n\n1\n0\n\\(∞\\)\n\n\n2\nfinite\n\\(\\dfrac{1}{K_a}\\)\n\n\n\n\nExercise 2 Consider a unity feedback system with open-loop transfer function \\[\nG(s) = \\dfrac{100(s+3)}{(s+1)(s+6)}\n\\] Find the steady state errors to step, ramp, and parabola inputs.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe first use Routh-Hurwitz to verify that the closed loop system is stable (left as an exercise).\nNote that \\(G(s)\\) is a type 0 system. Therefore, \\[\nK_p = \\lim_{s \\to 0} G(s) = \\frac{100 \\cdot 3 }{1 \\cdot 6 } = 50,\n\\quad\nK_v = 0,\n\\quad\nK_a = 0.\n\\] Thus, \\[\ne_{\\rm step}(∞) = \\frac{1}{1 + K_p} = \\frac{1}{51},\n\\quad\ne_{\\rm ramp}(∞) = \\frac{1}{K_v} = ∞,\n\\quad\ne_{\\rm para}(∞) = \\frac{1}{K_a} = ∞.\n\\]\n\n\n\n\nExercise 3 Consider a unity feedback system with open-loop transfer function \\[\nG(s) = \\dfrac{100(s+3)}{s(s+1)(s+6)}\n\\] Find the steady state errors to step, ramp, and parabola inputs.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nWe first use Routh-Hurwitz to verify that the closed loop system is stable (left as an exercise).\nNote that \\(G(s)\\) is a type 0 system. Therefore, \\[\nK_p =  ∞,\n\\quad\nK_v = \\lim_{s \\to ∞} s G(s) = \\frac{100 \\cdot 3 }{1 \\cdot 6 } = 50,\n\\quad\nK_a = 0.\n\\] Thus, \\[\ne_{\\rm step}(∞) = \\frac{1}{1 + K_p} = 0,\n\\quad\ne_{\\rm ramp}(∞) = \\frac{1}{K_v} = \\frac{1}{50},\n\\quad\ne_{\\rm para}(∞) = \\frac{1}{K_a} = ∞.\n\\]\n\n\n\nSteady-state errors are often part of the system specification. Depending on the system type, a constraint on the steady state error can be translated to a constraint on the appropriate error constant, which in turn can be used as a constraint on the tuneable parameters of the controller.\n\nExercise 4 Consider the system\n\nFind the value of \\(K\\) such that the steady state error to a ramp signal is less than \\(10\\%\\).\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThe constraint that \\(r_{\\rm ramp}(∞) \\le 0.1\\) implies that \\(K_v \\ge 10\\).\nThe velocity constant of the system is given by \\[\nK_v = \\lim_{s \\to 0} s \\cdot \\frac{K}{s} \\cdot G(s) =\n\\frac{K \\cdot 5}{2 \\cdot 10} = \\frac{K}{4}.\n\\]\nThus, \\[ K_v \\ge 10 \\implies K \\ge 40. \\]"
  },
  {
    "objectID": "steady-state-errors.html#steady-state-errors-for-non-unity-feedback-systems",
    "href": "steady-state-errors.html#steady-state-errors-for-non-unity-feedback-systems",
    "title": "Steady-state errors",
    "section": "4 Steady-state errors for non-unity feedback systems",
    "text": "4 Steady-state errors for non-unity feedback systems\nConsider a system with non-unity feedback as shown above. We can compute the steady-state error using the generic formula \\[\ne(∞) = \\lim_{s \\to 0} s R(s)(1 - T(s))\n= \\lim_{s \\to 0) s R(s) \\biggl[ \\frac{1 + G(s)H(s) - G(s)}{1 + G(s)H(s)} \\biggr].\n\\] However, in doing so, we lose the intuition that we have when using error constants with unity feedback system. In this section, we show that we can get back that intuition by converting a non-unity feedback system into a unity feedback system.\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n\n\n(c)\n\n\n\n\n\n\n\n(d)\n\n\n\n\n\n\nFigure 4: Unity feedback system equivalent to a non-unity feedback system\n\n\n\nFirst we observe that (a) and (b) in Figure 4 are equivalent. Then observe that (b) is equivalent to (c), which in turn is equivalent to (d) with \\[\n\\bbox[5pt,border: 1px solid]\n{G_e(s) = \\frac{G(s)}{1 + G(s)H(s) - G(s)}}\n\\]\n\nExercise 5 Consider the system\n\nFind the steady state errors to step, ramp, and parabola inputs.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nIn this case, the forward gain is \\(G(s) = 2/(s (s+2))\\) and the feedback gain \\(H(s) = 2\\). Thus,\n\\[\nG_e(s) = \\frac{ \\dfrac{2}{s(s+2)} }{1 + \\dfrac{4}{s(s+2)} - \\dfrac{2}{s(s+2)}}\n= \\frac{2}{s^2 + 2s + 2}.\n\\]\nThus, the equivalent system is a type 0 system with \\[\nK_p = \\lim_{s \\to 0} G(s) = 1,\n\\quad\nK_v = 0,\n\\quad\nK_a = 0.\n\\]\nThus, \\[\ne_{\\rm step}(∞) = \\frac{1}{1+K_p} = \\frac {1}{2},\n\\quad\ne_{\\rm ramp}(∞) = \\frac{1}{K_v} = ∞,\n\\quad\ne_{\\rm para}(∞) = \\frac{1}{K_a} = ∞.\n\\]"
  },
  {
    "objectID": "steady-state-errors.html#steady-state-errors-for-disturbances",
    "href": "steady-state-errors.html#steady-state-errors-for-disturbances",
    "title": "Steady-state errors",
    "section": "5 Steady-state errors for disturbances",
    "text": "5 Steady-state errors for disturbances\nTo be written"
  },
  {
    "objectID": "steady-state-errors.html#disturbance-rejection-for-non-unity-feedback-system",
    "href": "steady-state-errors.html#disturbance-rejection-for-non-unity-feedback-system",
    "title": "Steady-state errors",
    "section": "6 Disturbance rejection for non-unity feedback system",
    "text": "6 Disturbance rejection for non-unity feedback system\nTo be written"
  },
  {
    "objectID": "state-space-models.html",
    "href": "state-space-models.html",
    "title": "State space models",
    "section": "",
    "text": "The main idea behind state space models is to express constant coefficient linear differential equations as a first order vector differential equation. This representation allows us to use linear algebra to design controllers. To understand this, let’s start with a homogeneous first-order LDE: \\[\n\\frac{dy(t)}{dt} = a y(t)\n\\] with the initial condition \\(y(0) = y_0\\). We will write this equation as \\[\\bbox[5pt,border: 1px solid]\n{\\dot y(t) = a y(t), \\quad y(0) = y_0}\n\\] By inspection, we know that the solution is \\[y(t) = e^{at} y_0.\\]\nHowever, we lose this simplicity if we go to second or higher order LDEs. For example, consider the LDE: \\[\\frac{d^2y(t)}{dt^2} + a_1 \\frac{dy(t)}{dt} + a_0 y(t) = 0\\] which known initial conditions \\(y(0)\\) and \\(\\dot y(0)\\).\nHow can we find the solution? A commonly used method is to to use (one-sideded) Laplace transforms (with initial conditions) to compute the output. Recall \\[\\begin{align*}\n\\dot x(t) &\\xleftrightarrow{\\quad \\mathcal L\\quad} s X(s) - x(0) \\\\\n\\ddot x(t) &\\xleftrightarrow{\\quad \\mathcal L\\quad} s^2 X(s) - sx(0) - \\dot x(0).\n\\end{align*}\\]\nSo, if we take the LT of the DE, we get \\[\\begin{equation*}\n\\bigl[ s^2 Y(s) - s y(0) - \\dot y(0) \\bigr]\n+\na_1 \\bigl[s Y(s) - y(0) \\bigr]\n+\na_2 Y_0(s) = 0\n\\end{equation*}\\] Hence, \\[\nY(s) = \\frac{y(0) s + (a_1 y(0) + \\dot y(0))}{s^2 + a_1 s + a_0}.\n\\] We can now simplify the above using partial fractions expansion to compute \\(y(t)\\).\nState space models provide a nicer way to solve such DEs. In particular, we will provide a method to convert general \\(2\\)-nd order LDE into a vector equation \\[\\begin{align*}\n\\dot x(t) &= A x(t) \\\\\ny(t) &= C x(t)\n\\end{align*}\\] where \\(x(t) \\in \\reals^2\\), \\(A \\in \\reals^{2 × 2}\\) and \\(C \\in \\reals^{1 \\times 2}\\).\nWe will then look at general LTI systems and show that any \\(n\\)-th order TF can be written as a SSM: \\[\\begin{align*}\n\\dot x(t) &= A x(t) + B u(t) \\\\\ny(t) &= C x(t)\n\\end{align*}\\] where \\(x(t) \\in \\reals^n\\), \\(A \\in \\reals^{n × n}\\), \\(B \\in \\reals^{n \\times 1}\\) and \\(C \\in \\reals^{1 \\times n}\\).\nIn the next lecture, we will study how to solve such differential equations for a particular choice of input."
  },
  {
    "objectID": "state-space-models.html#sec-DE-SSM",
    "href": "state-space-models.html#sec-DE-SSM",
    "title": "State space models",
    "section": "1 Converting DE to SSM",
    "text": "1 Converting DE to SSM\nIn this section, we show how to construct SSM from DE. The key point to realize is that the SSM is not unique, so we will consider different representations. Each representation is useful for a specific purpose, as we will see later in the course.\nWe assume that we are either given a normalized DE (i.e., the leading coefficient is 1): \\[\n\\frac{d^n y(t)}{dt^n} + a_{n-1} \\frac{d^{n-1}y(t)}{dt}\n+ \\cdots + a_0  y(t)\n=\nb_m \\frac{d^m u(t)}{dt^m} + \\cdots + b_0 u(t)\n\\] or a normalized TF \\[G(s) = \\frac{b_m s^m + \\cdots + b_0}{s^n + a_{n-1}s^{n-1} + \\cdots + a_0}.\\]\nWe will restrict attention to proper TFs, i.e., \\(m &lt; n\\). There are three canoncial realizations, which we illustrate via examples first.\n\nControllable Canonical Form (CCF)\nObservable Canonical Form (OCF)\nDiagonal Canonical Form (DCF)"
  },
  {
    "objectID": "state-space-models.html#illustrative-example",
    "href": "state-space-models.html#illustrative-example",
    "title": "State space models",
    "section": "2 Illustrative Example",
    "text": "2 Illustrative Example\n\n2.1 CCF representation\nConsider the homogeneous second order DE considered above: \\[\\begin{equation}\\label{eq:2nd-DE}\n\\frac{d^2y(t)}{dt^2} + a_1 \\frac{dy(t)}{dt} + a_0 y(t) = 0.\n\\end{equation}\\]\nWe consider a state vector: \\[\nx(t) = \\MATRIX{x_1(t) \\\\ x_2(t)} = \\MATRIX{y(t) \\\\ \\dot y(t)}. \\] Then, we can write \\(\\eqref{eq:2nd-DE}\\) as follows: \\[\\begin{align*}\n  \\dot x_1(t) &= x_2(t) \\\\\n  \\dot x_2(t) &= - a_0 x_1(t) - a_1 x_2(t)\n\\end{align*}\\] This equation can be written in vector form as follows: \\[\\begin{align*}\n\\MATRIX{\\dot x_1(t) \\\\ \\dot x_2(t) }\n&=\n\\MATRIX{0 & 1 \\\\ -a_0 & -a_1} \\MATRIX{x_1(t) \\\\ x_2(t) },\n\\\\\ny(t) &= \\MATRIX{\\phantom{-a_0}\\llap{1} & \\phantom{-a_1}\\llap{0} } \\MATRIX{x_1(t) \\\\ x_2(t)}.\n\\end{align*}\\] This is called controllable cannonical form (CCF) realization of \\(\\eqref{eq:2nd-DE}\\). The meaning of the terminology will become clear later.\n\n\n2.2 OCF representation\nThe second method to obtain a SSM from the LDE is as follows. Write the LDE \\(\\eqref{eq:2nd-DE}\\) as an integro-differential equation: \\[\\begin{align*}\n\\ddot y(t) &= - a_1 \\dot y(t) + a_0 y(t)\n\\\\\n\\implies \\quad\n\\dot y(t) &= - a_1  y(t) + a_0 \\int_{0^-}^t y(\\tau)d\\tau\n\\end{align*}\\] Now define \\[\\begin{align*}\nx_1(t) &= -a_0\\int_{0^-}^t y(\\tau) d\\tau ,\n&\nx_2(t) &= y(t)\n\\end{align*}\\] Then, \\[\\begin{align*}\n\\dot x_1(t) &= -a_0 y(t) = -a_0 x_2(t) \\\\\n\\dot x_2(t) &= \\dot y(t) = x_1(t) - a_1 x_2(t)\n\\end{align*}\\] This equation can be written in vector form as follows: \\[\\begin{align*}\n\\MATRIX{\\dot x_1(t) \\\\ \\dot x_2(t) }\n&=\n\\MATRIX{0 & -a_0 \\\\ 1 & -a_1} \\MATRIX{x_1(t) \\\\ x_2(t) },\n\\\\\ny(t) &= \\MATRIX{0 & \\phantom{-a_1}\\llap{1} } \\MATRIX{x_1(t) \\\\ x_2(t)}.\n\\end{align*}\\] This is called observable canoncial form (OCF) realization of \\(\\eqref{eq:2nd-DE}\\). Again, the reason for the terminolgy will become clear later.\n\n\n\n\n\n\nNon-uniqueness of the SSM realization\n\n\n\nThe above example shows that the same DE can have multiple SSM realizations."
  },
  {
    "objectID": "state-space-models.html#general-form",
    "href": "state-space-models.html#general-form",
    "title": "State space models",
    "section": "3 General form",
    "text": "3 General form\nWe now consider a general second order TF: \\[ G(s) = \\frac{b_1 s+b_0}{s^2 + a_1 s + a_0} \\]\nAs an illustration, we will also use the following numerical example:\n\nExample 1 \\[ G(s) = \\frac{s+5}{s^2 + 3s + 2} \\]\n\n\n3.1 CCF representation\nFor the generic second order system, the CCF form is \\[\nA = \\MATRIX{ 0 & 1 \\\\ \\textcolor{red}{-a_0} & \\textcolor{red}{-a_1} },\n\\quad\nB = \\MATRIX{ 0 \\\\ 1},\n\\quad\nC = \\MATRIX{\\textcolor{red}{b_0} & \\textcolor{red}{b_1} }\n\\] This is the general structure of the matrix, where only the red elements have to be filled based on the TF. For example, for the TF in Example 1, we have \\[\nA = \\MATRIX{ 0 & 1 \\\\ -2 & -3 }\n\\quad\nB = \\MATRIX{ 0 \\\\ 1},\n\\quad\nC = \\MATRIX{5 & 1}\n\\]\nIn general, we have the following: \n\n\n3.2 OCF representation\nFor the generic second order system, the OCF form is \\[\nA = \\MATRIX{ 0 & \\textcolor{red}{-a_0} \\\\ 1 & \\textcolor{red}{-a_1} },\n\\quad\nB = \\MATRIX{\\textcolor{red}{b_0} \\\\ \\textcolor{red}{b_1} },\n\\quad\nC = \\MATRIX{ 0 & 1}\n\\] This is the general structure of the matrix, where only the red elements have to be filled based on the TF. For example, for the TF in Example 1, we have \\[\nA = \\MATRIX{ 0 & -2 \\\\ 1 & -3 }\n\\quad\nB = \\MATRIX{5 \\\\ 1},\n\\quad\nC = \\MATRIX{ 0 & 1},\n\\]\nIn general, we have the following: \n\n\n3.3 DCF representation\nThis representation is special and only applicable when the system has distinct real roots. Then, using the partial fraction expansion, the TF may be written as \\[\nG(s) = \\frac{c_1}{s+p_1} + \\frac{c_2}{s + p_2} + \\dots + \\frac{c_n}{s+p_n}\n\\] In DCF, the system matrices are given by \nIn particular, for the TF in Example 1, we have \\[\nG(s) = \\frac{s+5}{s^2 + 3s + 2} = \\frac{4}{s+1} - \\frac{3}{s+2}. \\]\nThus, \\[\nA = \\MATRIX{-1 & 0 \\\\ 0 & -2},\n\\quad\nB = \\MATRIX{ 1 \\\\ 1 },\n\\quad\nC = \\MATRIX{4 & -3}.\n\\]\nIn general, the poles will be complex and have multiplicity. In this setting, a generalization of DCF known as Jordan canconical form (JCF) is used. We will not consider JCF in this course."
  },
  {
    "objectID": "state-space-models.html#ssms-for-circuits",
    "href": "state-space-models.html#ssms-for-circuits",
    "title": "State space models",
    "section": "4 SSMs for circuits",
    "text": "4 SSMs for circuits\nWe will use the following notation in this section: \\(v(t)\\) denotes voltage, \\(i(t)\\) denotes current, and \\(q(t)\\) denotes charge.\nFor the three main circuit elements, we have the following relationship:\n\n\n\n\n\n\n\n\n\nRelationship\nResistor\nCapcitor\nInductor\n\n\n\n\n\n\n\n\n\n\nvoltage-current\n\\(v(t) = R i(t)\\)\n\\(\\displaystyle v(t) = \\frac{1}{C} \\int_{0}^t i(τ) d τ\\)\n\\(\\displaystyle \\bbox[5pt, background-color:lightgray]{v(t) = L \\frac{di(t)}{dt}}\\)\n\n\ncurrent-voltage\n\\(\\displaystyle i(t) = \\frac{1}{R} v(t)\\)\n\\(\\bbox[5pt, background-color:lightgray]{\\displaystyle i(t) = C \\frac{dv(t)}{dt}}\\)\n\\(i(t) = \\displaystyle \\frac 1L \\int_{0}^t v(τ) d τ\\)\n\n\nvoltage-charge\n\\(v(t) = R \\dfrac{dq(t)}{dt}\\)\n\\(v(t) = \\dfrac{1}{C} q(t)\\)\n\\(v(t) = L \\dfrac{d^2q(t)}{dt^2}\\)\n\n\n\nEach energy storage element (i.e., capacitor and inductor) gives rise to a state variable. We want to avoid integral equations, so for capacitor we choose voltage as state and for inductor we choose current as state.\n\n4.1 Example 1\nAs an example, let’s start with a simple example to understand how state space modeling works. Let’s consider an RCL circuit shown in Figure 1.\n\n\n\n\n\n\nFigure 1: A simple circuit\n\n\n\nWe construct the state space model as follows.\n\n4.1.1 Step 1: Select the state variables\nWe write the appropriate relation for the two energy storage elements: \\[\\begin{align*}\nC \\frac{d v_C(t)}{dt} &= i_C(t) = i_L(t) \\\\\nL \\frac{d i_L(t)}{dt} &= v_L(t)\n\\end{align*}\\]\nThus, we use \\(\\MATRIX{ v_C(t) \\\\ i_L(t) }\\) as state.\n\n\n4.1.2 Step 2: Use KCL/KVL to simplify the RHS of step 1\nWe want a relationship between input \\(u(t)\\) and output \\(v_C(t)\\). So, we use KCL/KVL to find a relationship between them. In this example, we use KVL: \\[\\begin{align*}\nu(t) &= v_R(t) + v_L(t) + v_C(t) \\\\\n&= R i_L(t) - L \\frac{di_L(t)}{dt} + v_C(t)\n\\end{align*}\\]\nThus, we have \\[\\begin{align*}\n\\frac{d v_C(t)}{dt} &= \\frac{1}{C} i_L(t) \\\\\n\\frac{d i_L(t)}{dt} &= - \\frac{1}{L} v_C(t) + \\frac{R}{L} i_L(t) + \\frac{1}{L} u(t)\n\\end{align*}\\]\nThus, the SSM is: \\[\n\\def\\1{\\vphantom{\\dfrac{d}{dt}}}\n\\bbox[5pt,background-color: lightgray]\n{\n\\begin{align*}\n\\MATRIX{ \\dfrac{d v_C(t)}{dt} \\\\ \\dfrac {d i_L(t)}{dt} }\n&=\n\\MATRIX{0 & \\dfrac{1}{C} \\\\ -\\dfrac{1}{L} & - \\dfrac{R}{L} }\n\\MATRIX{ \\1 v_C(t) \\\\  \\1 i_L(t) }\n+\n\\MATRIX{\\1 0 \\\\ \\dfrac{1}{L}} u(t)\n\\\\\ny(t) &= \\MATRIX{1 & 0}\n\\MATRIX{ \\1 v_C(t) \\\\  \\1 i_L(t) }\n\\end{align*}\n}\n\\]\nThus, we have \\[\n\\def\\1{\\vphantom{\\dfrac{d}{dt}}}\nA =\n\\MATRIX{0 & \\dfrac{1}{C} \\\\ -\\dfrac{1}{L} & - \\dfrac{R}{L} }\n,\n\\quad\nB =\n\\MATRIX{\\1 0 \\\\ \\dfrac{1}{L}},\n\\quad\nC = \\MATRIX{1 & 0 }\n\\]"
  },
  {
    "objectID": "state-space-models.html#from-state-space-models-to-transfer-functions",
    "href": "state-space-models.html#from-state-space-models-to-transfer-functions",
    "title": "State space models",
    "section": "5 From state space models to transfer functions",
    "text": "5 From state space models to transfer functions\nSo far, we have seen how to write different SSM representations from a TF. It is also possible to go in the other directions.\nSuppose we have a SSM: \\[\\begin{align*}\n\\dot x(t) &= A x(t) + B u(t) \\\\\ny(t) &= C x(t)\n\\end{align*}\\] Then the transfer function is \\[\n  \\bbox[5pt,border: 1px solid]\n  {G(s) = C(sI - A)^{-1} B }\n\\]\n\n\n\n\n\n\nDerivation of the formula\n\n\n\n\n\nTake LT of the SSM: \\[\\begin{align*}\ns X(s) &= A X(s) + B U(s)\n& \\implies&&\nX(s) &= (sI - A)^{-1} B U(s) \\\\\nY(s) &= C X(s)\n& \\implies&&\nY(s) &= C(sI - A)^{-1} B U(s)\n\\end{align*}\\]\nHence, \\[ G(s) = \\frac{Y(s)}{U(s)} = C(sI - A)^{-1} B.\\]\n\n\n\n\n\nExample 2 Let \\(A = \\MATRIX{-1 & 2 \\\\ 3 & -1}\\), \\(B = \\MATRIX{1 \\\\ 0}\\), and \\(C = \\MATRIX{2 & 1}\\). Find the TF?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nNote that \\[sI - A = \\MATRIX{s+1 & -2 \\\\ -3 & s+1}.\\]\nTherefore, \\[\\det(sI-A) = (s+1)^2 - 6 = s^2 + 2s -5. \\]\nHence, \\[(sI - A)^{-1} = \\frac{1}{\\det(sI-A)} \\MATRIX{s+1 & 2 \\\\ 3 & s+1}.\\]\nFinally, \\[G(s) = C(sI-A)^{-1}B\n=\n\\frac{1}{\\det(sI-A)} \\MATRIX{2 & 1} \\MATRIX{s+1 & 2 \\\\ 3 & s+1} \\MATRIX{1 \\\\ 0}\n= \\frac{2s + 5}{s^2 + 2s - 5}.\\]\n\n\n\nRecall that \\(\\det(sI-A)\\) is the characteristic equation of \\(A\\) and the roots of the characteristic equation are the eigenvalues of \\(A\\). Therefore, an important implication of the above formula is \\[\\bbox[5pt,border: 1px solid]\n{\\text{Poles of $G(s)$} = \\text{evals of $A$}}\\] This means that we can control the poles of the TF by controlling the eigenvalues of \\(A\\).\nChanging the eigenvalues of the \\(A\\) matrix will be one of the most simple and the most important design methods that we will learn in this course."
  },
  {
    "objectID": "state-space-models.html#change-of-coordinates",
    "href": "state-space-models.html#change-of-coordinates",
    "title": "State space models",
    "section": "6 Change of coordinates",
    "text": "6 Change of coordinates\nA key idea for controller design using state space methods is change of coordinates. To fix ideas, we first review the change of coordinates for vectors and then we will come back to SSMs.\nConsider a vector space \\(\\reals^2\\). The standard basis for \\(\\reals^2\\) is \\[\ne_1 = \\MATRIX{1 \\\\ 0}\n\\quad\\text{and}\\quad\ne_2 = \\MATRIX{0 \\\\ 1}.\n\\] When we write \\(x = \\MATRIX{x_1 \\\\ x_2} \\in \\reals^2\\), what we really mean is \\[x = x_1 e_1 + x_2 e_2.\\]\nWhat happens if we choose a different basis, say \\(v_1\\) and \\(v_2\\). If the vector \\[\n  x = \\tilde x_1 v_1 + \\tilde x_2 v_2\n\\] then we can say that the vector is equal to \\(\\MATRIX{\\tilde x_1 \\\\ \\tilde x_2}\\) in the coordinate system \\((v_1, v_2)\\). Note that the vector hasn’t changed, only the coodinate system has.\nWe use the following example to illustrate how to move from one coordinate system to another\n\nExample 3 Let \\(x = \\MATRIX{2 \\\\ 3}\\). Find its representation in the coordinate system \\[v_1 = \\MATRIX{1 \\\\ 0}\n\\quad\\text{and}\\quad\nv_2 = \\MATRIX{1 \\\\ 1}.\n\\]\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLet the representation in the new coordinate system be \\(\\tilde x = \\MATRIX{\\tilde x_1 \\\\ \\tilde x_2}\\). Thus, we must have \\[\n2 e_1 + 3 e_2 = \\tilde x_1 v_1 + \\tilde x_2 v_2.\n\\] Or, in vector form, \\[ \\MATRIX{1 & 0 \\\\ 0 & 1} \\MATRIX{2 \\\\ 3}\n=\n\\MATRIX{1 & 1 \\\\ 0 & 1} \\MATRIX{\\tilde x_1 \\\\ \\tilde x_2}\n\\] which can be written as \\[\\bbox[5pt,border: 1px solid]\n{ x = T \\tilde x}\n\\] where \\[T = \\MATRIX{v_1 & v_2} = \\MATRIX{1 & 1 \\\\ 0 & 1}.\\] The matrix \\(T\\) is full rank (which is always the case if \\(\\text{span}(v_1,v_2) = \\reals^2\\). Thus, we have \\[\\bbox[5pt,border: 1px solid]\n{ \\tilde x = T^{-1} x}\n\\]\nSo, for the above example we have \\[\\tilde x = \\MATRIX{1 & 1 \\\\ 0 & 1}^{-1} \\MATRIX{2 \\\\ 3}\n= \\MATRIX{-1 \\\\ 3}.\\]"
  },
  {
    "objectID": "state-space-models.html#change-of-coordinates-in-ssms",
    "href": "state-space-models.html#change-of-coordinates-in-ssms",
    "title": "State space models",
    "section": "7 Change of coordinates in SSMs",
    "text": "7 Change of coordinates in SSMs\nConsider a SSM: \\[\\begin{align*}\n\\dot x(t) &= A x(t) + B u(t) \\\\\ny(t) &= C x(t)\n\\end{align*}\\]\nLet \\(T\\) be any invertible \\(n × n\\) matrix. Such a matrix is called a similarity matrix. Think of columns of \\(T\\) as the basis of a new coordinate system. Then, the state can be written as \\[ \\tilde x(t) = T^{-1} x(t) \\] in the new coordinate system.\n\nWhat are the stae space equations in the new coordinate system?\nHow does the change of coordinates affect the TF?\n\nWe look at both these questions in detail.\nSince \\(\\tilde x(t) = T^{-1} x(t)\\), we have \\(x(t) = T \\tilde x(t)\\). Substituting this in the SSM, we have \\[\\begin{align*}\nT \\dot {\\tilde x}(t) &= A T \\tilde x(t) + B u(t) \\\\\ny(t) &= C T \\tilde x(t)\n\\end{align*}\\]\nPre-multiply the first equation by \\(T^{-1}\\): \\[\\begin{align*}\n\\dot {\\tilde x}(t) &= T^{-1} A T \\tilde x(t) + T^{-1} B u(t) \\\\\ny(t) &= C T \\tilde x(t)\n\\end{align*}\\]\nSo, we can think of this as a new SSM: \\[\\begin{align*}\n\\dot {\\tilde x}(t) &= \\tilde A \\tilde x(t) + \\tilde B u(t) \\\\\ny(t) &= \\tilde C \\tilde x(t)\n\\end{align*}\\] where \\[\\bbox[5pt,border: 1px solid]\n{\\tilde A = T^{-1} A T,\n\\quad\n\\tilde B = T^{-1} B,\n\\quad\n\\tilde C = CT}\n\\]\nThe coordinate transformation has the following properties:\n\nCoordinate transformation does not change the characteristic function\nNote that \\[\\begin{align*}\n(sI - \\tilde A) &= sI - T^{-1} A T \\\\\n&= s T^{-1} I T - T^{-1} A T \\\\\n&= T^{-1} (sI - A) T.\n\\end{align*}\\] Therefore, \\[\n\\det(sI - \\tilde A) = \\det(T^{-1}) \\det(sI - A) \\det(T)\n= \\det(sI - A)\n\\] because \\(\\det(T^{-1}) \\det(T) = \\det(T^{-1} T) = \\det(I) = 1\\).\nCoordinate transformation does not change the TF\nThe transfer function in the new coordinate system is \\[\\begin{align*}\n\\tilde G(s) &= \\tilde C(sI - \\tilde A)^{-1} \\tilde B \\\\\n&= C T T^{-1} (sI - A)^{-1} T T^{-1} B \\\\\n&= C(sI - A)^{-1} B = G(s)\n\\end{align*}\\]\n\nThese properties hold because the change of coordinates (or similarity transformation) does not physically change the state; it only changes the coordinate system that we are using to represent the state.\nChange of coordinates (or similarity transformation) is a very useful tool for control system syntehsis. As we will see later, it is easy to design controllers for systems in CCF. So, when we have to design controllers for systems not in CCF, we first find a similarity transformation that converts the system to CCF; then we design a controller for the system in CCF; and finally we convert the controller back to the original coordinate system. Don’t worry if this doesn’t make sense notw. We will discuss this in detail in the next few lectures."
  },
  {
    "objectID": "freq-modeling.html",
    "href": "freq-modeling.html",
    "title": "Frequency domain modeling",
    "section": "",
    "text": "A comment about notation\n\n\n\nIn Signals and Systems, we used \\(u(t)\\) to denote the step function. In this course, we will use \\(u(t)\\) to denote the control input. So, to avoid confusion, we will use \\(\\mathbb{1}(t)\\) to denote the step function. Note that the book uses \\(u(t)\\), which can get confusing, in my opinion.\nIn this lecture, we will review frequency domain modeling of LTI (linear and time invariant) systems. You have seen this material in Signals and Systems. The purpose of this review is to simply introduce the notation used in this course, in case it happens to be different from the notation used in Signals and Systems. You are strongly encouraged to review your notes on this topic."
  },
  {
    "objectID": "freq-modeling.html#unilateral-laplace-transforms",
    "href": "freq-modeling.html#unilateral-laplace-transforms",
    "title": "Frequency domain modeling",
    "section": "1 Unilateral Laplace Transforms",
    "text": "1 Unilateral Laplace Transforms\nRecall that there are two types of Laplace transforms (LTs): bi-lateral or two-sided LTs and unilateral or one-sided LTs. In this course, we will work exclusively with unilateral LTs.\nAlso recall that for two-sided LTs, we need to worry about the ROC (region of convergence). For one-sided LTs, we never explicitly mention the ROC since it is always the right hand plane right to the rightmost pole.\nWe will use the notation \\[f(t) \\xleftrightarrow{\\quad\\mathcal L\\quad} F(s)\\] to denote a LT-pair. We will also use \\[F(s) = \\mathcal{L}\\{ f(t)\\}\\] or \\[f(t) = \\mathcal L^{-1}\\{F(s)\\}\\] when we want to explicitly write the LT or the inverse LT of a signal.\n\nThe basic formula for a unilateral LT is \\[F(s) = \\int_{0-}^{\\infty} f(t)e^{-st} dt.\\] The inverse Laplace transform is given by \\[f(t) = \\frac{1}{2\\pi j} \\int_{\\sigma - j \\infty}^{\\sigma + j \\infty} F(s) e^{st} ds\\] where \\(\\sigma\\) is chosen such that \\((\\sigma,0)\\) is in the ROC.\nIn this course, we will never explicitly use these formulas to compute LTs. We will always use LT tables. You do not need to memorize the LT table; one will be provided during the examples. What you do need is the understanding of how to use the LT tables to compute LTs of complicated expressions and to compute inverse LTs using partial fraction expansion.\nI will not review this material in class. Please go back to your SS notes or review Sec 2.1–2.2 of the textbook. In is important to understand the following three cases:\n\nRoots of the denominator are real and distinct\nRoots of the denominator are complex and distinct\nRoots of the denominator are real and repeated."
  },
  {
    "objectID": "freq-modeling.html#the-transfer-function",
    "href": "freq-modeling.html#the-transfer-function",
    "title": "Frequency domain modeling",
    "section": "2 The Transfer Function",
    "text": "2 The Transfer Function\nIn this course, we will work exclusively with LTI systems. Such systems arise in all branches of engineering, e.g., electrical circuits, spring-mass systems, gear systems, and thermodynamics. See Chapter 2 of Nice for detailed modeling examples.\nConsider an LTI system with input \\(u(t)\\) (also called the reference signal sometimes) and output \\(y(t)\\). We can also represent this as the following block diagram:\n\n\n\n\n\n\nFigure 1: An LTI System\n\n\n\nAll such systems can be represented by constant coefficient linear differential equations (LDE) of the form \\[\na_n \\frac{d^n y(t)}{dt^n}  + a_{n-1} \\frac{d^{n-1} y(t)}{dt^{n-1}} + \\cdots  a_0 y(t)\n= b_m \\frac{d^m u(t)}{dt^m} + b_{m-1} \\frac{d^{m-1} u(t)}{dt^{m-1}} + \\cdots + b_0 u(t).\n\\]\n\nThis differential equation is called linear because there are no non-linear or multiplicative terms of the form \\(\\displaystyle \\left(\\frac{d^3 y(t)}{dt^3}\\right)\\left(\\frac{d^2 y(t)}{dt^2}\\right)\\).\nIt is called constant coefficient because the coefficients \\(a_n\\) and \\(b_m\\) are constants that do not depend on time.\n\nThere is a one-to-one correspondence between constant coefficient LDE and an LTI system. That is, every LTI system can be described by a constant coefficient LDE and vice-versa.\nRecall that a key defining property of an LTI system is its impulse response, which we will typically denote by \\(g(t)\\) and the transfer function, which we denote by \\(G(s)\\). Recall that \\(g(t) \\xleftrightarrow{\\quad \\mathcal L \\quad} G(s)\\).\nNow an interesting feature of a constant coefficient LDE is that we can identify the transfer function simply by inspection.\n\n\n\n\n\n\nFigure 2: An LTI System\n\n\n\nGiven an LTI system with input \\(u(t)\\) and output \\(y(t)\\), we know that \\[Y(s) = G(s)U(s).\\] Therefore, if we know the input and output, we can identify the transfer function using \\[ G(s) = \\frac{Y(s)}{U(s)}.\\] Now, if we go back to the general formula of a constant coefficient LDE \\[\na_n \\frac{d^n y(t)}{dt^n}  + a_{n-1} \\frac{d^{n-1} y(t)}{dt^{n-1}} + \\cdots  a_0 y(t)\n= b_m \\frac{d^m u(t)}{dt^m} + b_{m-1} \\frac{d^{m-1} u(t)}{dt^{m-1}} + \\cdots + b_0 u(t).\n\\] and assume that the system starts from zero-initial state and take the LT of both sides, we get \\[\na_n s^n Y(s) + a_{n-1} s^{n-1} Y(s) + \\cdots + a_0 Y(s)\n=\nb_m s^m U(s) + b_{m-1} s^{m-1} U(s) + \\cdots + b_m U(s).\n\\] Rearranging terms, we get \\[\n(a_n s^n + a_{n-1} s^{n-1} + \\cdots + a_0) Y(s)\n=\n(b_m s^m + b_{m-1}s^{m-1} + \\cdots + b_0) U(s).\n\\] Therefore, \\[\nG(s) = \\frac{Y(s)}{U(s)}\n= \\frac{b_m s^m + b_{m-1} s^{m-1} + \\cdots + b_m}\n{a_n s^n + a_{n-1} s^{n-1} + \\cdots + a_0}.\n\\] Thus, we can easily go back and forth between the DE and the transfer function.\n\nExercise 1 Find the transfer function corresponding to the following LDE \\[\n\\frac{d}{dt}y(t) + 2 y(t) = u(t)\n\\]\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFrom inspection, we have \\[G(s) = \\frac{1}{s + 2}\\]\n\n\n\n\nExercise 2 Find a LDE that implements the following TF \\[\nG(s) = \\frac{2s+1}{s^2 + 2s + 3}.\n\\]\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nFrom inspection, we have \\[\n\\frac{d^2c(t)}{dt} + 2\\frac{d y(t)}{dt} + 3c(t) = 2\\frac{d u(t)}{dt} + u(t).\n\\]\n\n\n\nIn this course, we will assume that the system is specified either as a LDE or as a TF. The textbook provides detailed examples of how to derive either the LDE or the TF from a physical system such as an electric circuit or a spring-mass system.\nWe present an alternative representation of the TF (pole-zero plot) in the next section. Later in the course we will also study other equivalent forms of representing the system such as state space equations and Bode plots.\nA final remark. In all the systems that we consider in this course, we will assume that \\(m &lt; n\\). So, the denominator of the TF has a strictly higher degree than the numerator. Such transfer functions are called proper. It is possible to have causal systems where \\(m=n\\) but we will not consider that in this course. As a consequence, when we consider state space representation in future lectures, we will get formulas which are simpler than more general formulas which you may find at other sources."
  },
  {
    "objectID": "freq-modeling.html#poles-and-zeros-of-a-transfer-function",
    "href": "freq-modeling.html#poles-and-zeros-of-a-transfer-function",
    "title": "Frequency domain modeling",
    "section": "3 Poles and Zeros of a Transfer Function",
    "text": "3 Poles and Zeros of a Transfer Function\nThe TF of an LTI system is always of the form: \\[\nG(s)\n= \\frac{b_m s^m + b_{m-1} s^{m-1} + \\cdots + b_m}\n{a_n s^n + a_{n-1} s^{n-1} + \\cdots + a_0}.\n\\]\nBoth the numerator and the denominator are polynomials in \\(s\\). So, we can factorize them and write the TF as \\[\nG(s)\n= K\n\\frac{(s-z_1)(s-z_2) \\cdots (s - z_m)}\n{(s-p_1)(s-p_2)\\cdots (s-p_n)}.\n\\] The roots of the numerator are called the zeros (because \\(G(z_i) = 0\\)). The roots of the denominator are called poles (because \\(G(p_i) = \\infty\\) and if we plot \\(G(s)\\) it will have a peak going to \\(∞\\) at \\(p_i\\); this peak looks like a pole). The constant \\(K\\) is called the gain (because, when none of the poles and zeros are at origin, the step response of \\(G(s)\\) will have a steady state value of \\(K\\)).\nWe often represent the poles and zeros using a pole-zero plot.\n\nPZplot = function(zeros, poles, xdomain, ydomain) {\n  return Plot.plot({\n    grid: true,\n    x: { domain: xdomain},\n    y: { domain: ydomain},\n\n    marks: [\n      // Axes\n      Plot.ruleX([0]),\n      Plot.ruleY([0]),\n      // Data\n      Plot.dot(zeros, {x:\"σ\", y:\"jω\", r: 5}),\n      Plot.dot(poles, {x:\"σ\", y:\"jω\", symbol: \"times\", r: 5}),\n    ]\n  })\n}\n\n\n\n\n\n\n\nExample 1 (Pole-zero plot) Consder \\[G(s) = \\frac{s+2}{(s+1)^2 + 1^2}.\\] The poles are \\(-1 \\pm j\\) and the zero is \\(-2\\). The pole-zero plot is shown below, where the location of the pole is represented by a “cross” and the location of the zero is represented by a “circle”.\n\nPZplot(\n       [ {σ: -2, jω: 0} ], \n       [ { σ: -1, jω: -1 }, {σ: -1, jω: 1 } ],\n       [-3, 3],\n       [-3, 3],\n      )\n\n\n\n\n\n\n\nSince the polynomials in the numerator and denominator of \\(G(s)\\) have real coefficients, the roots are either real or occur in complex conjugate pairs. So, the poles and zeros either lie on the \\(σ\\)-axis or are symmetric about the \\(σ\\)-axis.\nNote that the pole-zero plot does not capture the gain of the TF."
  },
  {
    "objectID": "freq-modeling.html#bibo-stability",
    "href": "freq-modeling.html#bibo-stability",
    "title": "Frequency domain modeling",
    "section": "4 BIBO Stability",
    "text": "4 BIBO Stability\nRecall from Signals and Systems that an LTI system with impulse response \\(g(t)\\) is BIBO stable if \\[\n\\int_{-∞}^{∞} |g(t)| dt &lt; \\infty.\n\\]\nFor a causal system (i.e., a system for which \\(g(t) = 0\\) for \\(t &lt; 0\\)), this is equivalent to \\[\n\\int_{0^{-}}^{∞} |g(t)| dt &lt; ∞.\n\\]\nThis implies that for any \\(σ \\in \\reals\\), \\(σ &gt; 0\\), we have \\[\n\\int_{0^{-}}^{∞} |g(t)| e^{-σt} dt &lt; ∞.\n\\]\nTherefore, there can be no pole in the open right hand plane \\(\\{ (σ + j ω) : σ &gt; 0 \\}\\). Thus, we have the following:\n\nA causal LTI system is stable if all poles are in the open left hand plane.\n\nPZplot(\n       [ {σ: 1.5, jω: 0} ], \n       [ { σ: -1, jω: -1 }, {σ: -1, jω: 1 }, {σ: -1.5, jω: 0} ],\n       [-2, 2],\n       [-2, 2],\n      )\nPZplot(\n       [ {σ: -1.5, jω: 0} ], \n       [ { σ: -1, jω: -1 }, {σ: -1, jω: 1 }, { σ: 1.5, jω: 0 } ],\n       [-2, 2],\n       [-2, 2],\n      )\nPZplot(\n       [ {σ: 1.5, jω: 0} ], \n       [ { σ: -1, jω: -1 }, {σ: -1, jω: 1 }, {σ: 0, jω: 0} ],\n       [-2, 2],\n       [-2, 2],\n      )\nPZplot(\n       [ {σ: 1.5, jω: 0} ], \n       [ { σ: -1, jω: -1 }, {σ: -1, jω: 1 }, {σ: -0.02, jω: 0}, {σ: 0.02, jω: 0} ],\n       [-2, 2],\n       [-2, 2],\n      )\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Stable systems\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Unstable systems\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) Marginally systems\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Unstable systems (double pole at origin)\n\n\n\n\n\n\n\nFigure 3: Illustration of stable and unstable systems\n\n\n\nIf there are poles on the \\(j ω\\) axis and the poles have multiplicity 1, then the system is marginally stable; if poles have multiplicity greater than 1, then the system is unstable.\nIn the next lecture, we will see how to use the poles to identify the step response of the system."
  },
  {
    "objectID": "freq-modeling.html#step-response",
    "href": "freq-modeling.html#step-response",
    "title": "Frequency domain modeling",
    "section": "5 Step Response",
    "text": "5 Step Response\nOne of the configurations that we will really focus on in the course is the output of a stable system when the input is a step function. This is often the case when we specify a reference input such as the desired temperature of a room or the desired speed in cruise control of a car, and are interested in seeing if we get a “good” output. Note that this question is only of interest for stable systems. If the system is unstable, then the output will go to infinity.\nAs an example, consider the system of Exercise 2. What is the output when the input is a step function (assuming that the system starts from a zero initial state)?\nTo compute this, recall \\[\n\\mathbb{1}(t) \\xleftrightarrow{\\quad \\mathcal L\\quad} \\frac 1s.\n\\]\nThus, \\(U(s) = 1/s\\). We had already identified that \\(G(s) = 1/(s+2)\\). Thus, \\[\\begin{align*}\nY(s) &= G(s) U(s) \\\\\n     &= \\frac{1}{s(s+2)} \\\\\n     &= \\frac{ \\frac 12 }{s} - \\frac{ \\frac 12 }{ s + 2 }\n     \\quad \\text{[By partial fraction expansion]}.\n\\end{align*}\\] Thus, \\[\n  y(t) = \\left[ \\frac 12 - \\frac 12 e^{-2t} \\right] \\mathbb{1}(t).\n\\]"
  },
  {
    "objectID": "freq-modeling.html#interconnection-of-lti-systems",
    "href": "freq-modeling.html#interconnection-of-lti-systems",
    "title": "Frequency domain modeling",
    "section": "6 Interconnection of LTI Systems",
    "text": "6 Interconnection of LTI Systems\nThere are three common ways to inter connect LTI systems shown below.\n\n\n\n\n\n\nFigure 4: Series Connection equivalent to \\(G_1(s)G_2(s)\\).\n\n\n\n\n\n\n\n\n\nFigure 5: Parallel Connection equivalent to \\(G_1(s) + G_2(s)\\).\n\n\n\n\n\n\n\n\n\nFigure 6: Feedback Connection equivalent to \\(\\displaystyle \\frac{G(s)}{1 + G(s)H(s)}\\)."
  },
  {
    "objectID": "freq-modeling.html#time-delay-systems",
    "href": "freq-modeling.html#time-delay-systems",
    "title": "Frequency domain modeling",
    "section": "7 Time-delay systems",
    "text": "7 Time-delay systems\nIn a real system, there is often a delay between input and output, which is often modeled by a delay block whose output \\(y(t)\\) is a delayed version of the input \\(u(t)\\), by a delay time \\(τ\\), that is \\[\n  y(t) = u(t-τ).\n\\] Taking the Laplace transform of both sides, we get \\[\nY(s) = e^{-τs}U(s).\n\\] Therefore, the TF of time-delay unit is \\(e^{-τs}\\), which is different from the TFs studied so far as it is not a rational polynomial of \\(s\\). It is possible to approximate \\(e^{-τs}\\) using a rational polynomial using what is called Padé approximation:\n\nFirst-order Padé approximation: \\[ e^{-τs} \\approx \\dfrac{1 - τs/2}{1 + τs/2}. \\]\nSecond-order Padé approximation: \\[ e^{-τs} \\approx \\dfrac{1 - τs/2 + (τs)^2/12}{1 + τs/2 + (τs)^2/12}. \\]"
  }
]