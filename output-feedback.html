<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Aditya Mahajan">
<meta name="dcterms.date" content="2024-12-06">

<title>State observers and output feedback â€“ Linear Systems and Control</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-d166b450ba5a8e9f7a0ab969bf6592c1.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-9ea16c1cb545fbfebfbd03958c344a8d.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-7d03948db9a048ac6b7c3dc6585b4b60.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="site_libs/quarto-contrib/nutshell-1.0.6/nutshell.js"></script>
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<script>
// https://github.com/mathjax/MathJax/issues/2744#issuecomment-1658624747
// To fix the bug that uppercase unicode letters are shown in italic
window.MathJax = {
  startup: {
    ready() {
      const {RANGES} = MathJax._.core.MmlTree.OperatorDictionary;
      const {TEXCLASS} = MathJax._.core.MmlTree.MmlNode;
      RANGES.splice(4, 1,
        [0x0370, 0x0385, TEXCLASS.ORD, 'mi'],
        [0x0386, 0x3AB, TEXCLASS.ORD, 'mi', 'normal'],
        [0x03AC, 0x1A20, TEXCLASS.ORD, 'mi']
      );
      MathJax.startup.defaultReady();
    }
  },
  tex: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: true,
    tags: "ams",
    macros: {
      PR: "\\mathbb{P}",
      EXP: "\\mathbb{E}",
      IND: "\\mathbb{1}",
      ONES: "\\mathbb{1}",
      reals: "\\mathbb{R}",
      integers: "\\mathbb{Z}",
      BLANK: "\\mathfrak{E}",
      TRANS: "\\intercal",
      VEC: "\\operatorname{vec}",
      diag: "\\operatorname{diag}",
      ROWS: "\\operatorname{vec}",
      TR: "\\operatorname{Tr}",   
      SPAN: "\\operatorname{span}",   
      ALPHABET: ["\\mathcal{#1}", 1],
      MATRIX: ["\\begin{bmatrix} #1 \\end{bmatrix}", 1],
      DET: ["\\begin{vmatrix} #1 \\end{vmatrix}", 1],
      NORM: ["\\left\\lVert \\mathstrut #1 \\right\\rVert", 1],
      ABS: ["\\left\\lvert \\mathstrut #1 \\right\\rvert", 1],
      GRAD: "\\nabla",
      IP: ["\\left\\langle #1, #2 \\right\\rangle", 2],
      iddots: "\\mathinner{ \\kern1mu\\raise1pt{.} \\kern2mu\\raise4pt{.} \\kern2mu\\raise7pt{\\Rule{0pt}{7pt}{0pt}.} \\kern1mu}",
    },
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
};
</script>
<script async="" data-id="101261731" src="//static.getclicky.com/js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./../linear-systems/index.html"> 
<span class="menu-text">Linear Control Systems</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#state-observer" id="toc-state-observer" class="nav-link active" data-scroll-target="#state-observer"><span class="header-section-number">1</span> State observer</a>
  <ul class="collapse">
  <li><a href="#a-naive-observer" id="toc-a-naive-observer" class="nav-link" data-scroll-target="#a-naive-observer"><span class="header-section-number">1.1</span> A naive observer</a></li>
  <li><a href="#the-luenberger-observer" id="toc-the-luenberger-observer" class="nav-link" data-scroll-target="#the-luenberger-observer"><span class="header-section-number">1.2</span> The Luenberger observer</a></li>
  </ul></li>
  <li><a href="#observer-design-for-systems-in-ocf" id="toc-observer-design-for-systems-in-ocf" class="nav-link" data-scroll-target="#observer-design-for-systems-in-ocf"><span class="header-section-number">2</span> Observer design for systems in OCF</a></li>
  <li><a href="#observer-design-for-systems-not-in-ocf" id="toc-observer-design-for-systems-not-in-ocf" class="nav-link" data-scroll-target="#observer-design-for-systems-not-in-ocf"><span class="header-section-number">3</span> Observer design for systems not in OCF</a>
  <ul class="collapse">
  <li><a href="#observability-matrix" id="toc-observability-matrix" class="nav-link" data-scroll-target="#observability-matrix"><span class="header-section-number">3.1</span> Observability matrix</a></li>
  <li><a href="#observer-design" id="toc-observer-design" class="nav-link" data-scroll-target="#observer-design"><span class="header-section-number">3.2</span> Observer design</a></li>
  </ul></li>
  <li><a href="#output-feedback" id="toc-output-feedback" class="nav-link" data-scroll-target="#output-feedback"><span class="header-section-number">4</span> Output feedback</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/adityam/linear-systems/edit/quarto/output-feedback.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">State observers and output feedback</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author"><a href="https://adityam.github.io">Aditya Mahajan</a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            <a href="http://www.mcgill.ca/ece">
            McGill University
            </a>
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Updated</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 6, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="state-observer" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="state-observer"><span class="header-section-number">1</span> State observer</h2>
<p>So far, we have assumed that the controller has access to the state of the system. In many systems, it is either too expensive or physically impossible to place enough sensors to observe all the components of the state. In such cases, one option is to estimate the state from the inputs and outputs of the system and use the estimated state to chose the control input. The system which generates a state estimate from inputs and outputs is called an <strong>observer</strong>.</p>
<p>An estimate <span class="math inline">\(\hat x(t)\)</span> of the state <span class="math inline">\(x(t)\)</span> should have two properties:</p>
<ul>
<li>It should be asymptotitcally consistent, i.e., <span class="math inline">\(\lim_{t \to âˆž} \NORM{x(t) - \hat x(t)} = 0\)</span>.</li>
<li>We should be able to control the rate of convergence.</li>
</ul>
<p>We state with a naive observer to show that it is possible to obtain asymptotically consistent estimators. We then consider how to modify the naive observer to be able to to control the rate of convergence.</p>
<section id="a-naive-observer" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="a-naive-observer"><span class="header-section-number">1.1</span> A naive observer</h3>
<p>The main idea of building an observer is to start with a (physical or digital) replica of the original system, provide it the same inputs as the original system, and measure the internal state of the replica. In particular, we start with an initial guess <span class="math inline">\(\hat x(0)\)</span> and then update the estimate according to <span class="math display">\[
\dot {\hat x}(t) = A \hat x(t) + B u(t).
\]</span></p>
<p>A feature of this observer is that if our initial guess <span class="math inline">\(\hat x(0)\)</span> is equal to the true initial conditions of the system then <span class="math inline">\(\hat x(t) = x(t)\)</span> for all <span class="math inline">\(t\)</span>. If the initial guess is wrong, then there is an error <span class="math inline">\(e(t) = x(t) - \hat x(t)\)</span> in measuring the state of the system. The evolution of the error is given by: <span class="math inline">\(e(0) = x(0) - \hat x(0)\)</span> and <span class="math display">\[
  \dot e(t) = \dot x(t) - \dot {\hat x}(t) = A e(t).
\]</span> This is a vector linear differential equation. Hence, <span class="math display">\[
  e(t) = \exp(At) e(0).
\]</span> Thus, if <span class="math inline">\(A\)</span> is internally stable (i.e., all the eigenvalues of <span class="math inline">\(A\)</span> lie in the OLHP), then the error <span class="math inline">\(e(t)\)</span> will converge to zero. However, we have no ability to influence the rate of convergence (which depends on the eigenvalues of <span class="math inline">\(A\)</span>).</p>
</section>
<section id="the-luenberger-observer" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="the-luenberger-observer"><span class="header-section-number">1.2</span> The Luenberger observer</h3>
<p>The Luenberger observer is given as follows. Start with an initial guess <span class="math inline">\(\hat x(0)\)</span> and update the estimate according to <span class="math display">\[
\dot {\hat x}(t) = A \hat x(t) + B u(t) + L( y(t) - C \hat x(t))
\]</span> where <span class="math inline">\(L = \MATRIX{ \ell_0 &amp; \cdots &amp; \ell_{n-1}}^\TRANS\)</span> is called the <strong>observer gain</strong>.</p>
<p>In this case, the error <span class="math inline">\(e(t) = x(t) - \hat x(t)\)</span> evolves as follows. The initial state <span class="math inline">\(e(0) = x(0) - \hat x(0)\)</span> and <span class="math display">\[
\dot e(t) = \dot x(t) - \dot {\hat x}(t) = (A - LC) e(t).
\]</span> This is a vector linear differential equation.Hence, <span class="math display">\[
  e(t) = \exp( (A-LC)t) e(0).
\]</span> Thus, if <span class="math inline">\(A - LC\)</span> is stable, then the error will converge to zero with a rate that is determined by the eigenvalues of <span class="math inline">\(A - LC\)</span>.</p>
<p>Thus, designing an observer gain is similar in spirit to designing a feedback gain for state feedback. In state feedback design, we are given <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> matrices and we want to choose a gain <span class="math inline">\(K\)</span> such that the eigenvalues of <span class="math inline">\(A - BK\)</span> take desired values; in observer desgin, we are given <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span> matrices and we want to choose a gain <span class="math inline">\(:\)</span> such that the eigenvalues of <span class="math inline">\(A - LC\)</span> take desired values.</p>
<p>As was the case for state feedback, we will start with system in OCF and show that observer design for such systems can be done by simply comparing the coefficients of the characteristic polynomials of the open-loop system and the desired characteristic polynomial of <span class="math inline">\(A - LC\)</span>. We then look at systems that are not in OCF and show that if the system satisfies a condition known as <strong>observability</strong>, we can find a transformation that converts the system to OCF, design the observer gain for the OCF representation, and translate it back to the original coordinate system.</p>
</section>
</section>
<section id="observer-design-for-systems-in-ocf" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="observer-design-for-systems-in-ocf"><span class="header-section-number">2</span> Observer design for systems in OCF</h2>
<p>Consider a state feedback system in OCF with <span class="math display">\[
A = \MATRIX{ 0 &amp; \cdots &amp; \cdots &amp; 0 &amp; - a_0 \\
             1 &amp; 0 &amp; \cdots &amp; 0 &amp; - a_1 \\
             0 &amp; 1 &amp; \ddots &amp; 0 &amp; -a_2 \\
             \vdots &amp; \ddots &amp; \ddots &amp; \vdots &amp; \vdots \\
             0 &amp; \cdots &amp; \cdots &amp; 1 &amp; -a_{n-1} }
,\quad
C = \MATRIX{0 &amp; \cdots &amp; 0 &amp; 1}.
\]</span></p>
<p>We want to design a Luenberger observer <span class="math display">\[
\dot {\hat x}(t) = A \hat x(t) + B u(t) + L (y(t) - C \hat x(t)),
\quad \text{where }
L = \MATRIX{\ell_0 \\ \vdots \\ \ell_{n-1}}
\]</span> such that the characteristic polynomial of <span class="math inline">\(A - LC\)</span> is <span class="math display">\[
\det(sI _ A + LC) = s^n + Î±_{n-1} s^{n-1} + \cdots + Î±_0.
\]</span></p>
<p>Observe that <span class="math display">\[
LC = \MATRIX{\ell_0 \\ \vdots \ell_{n-1}}
\MATRIX{0 &amp; \cdots &amp; 0 &amp; 1 }
= \MATRIX{0  &amp; \cdots &amp; 0 &amp; - \ell_0 \\
          \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
          0  &amp; \cdots &amp; 0 &amp; - \ell_{n-1}}
\]</span> Thus, <span class="math display">\[
A - LC = \MATRIX{ 0 &amp; \cdots &amp; \cdots &amp; 0 &amp; -(a_0 + \ell_0) \\
             1 &amp; 0 &amp; \cdots &amp; 0 &amp; - (a_1 + \ell_1) \\
             0 &amp; 1 &amp; \ddots &amp; 0 &amp; -(a_2 + \ell_2)\\
             \vdots &amp; \ddots &amp; \ddots &amp; \vdots &amp; \vdots \\
             0 &amp; \cdots &amp; \cdots &amp; 1 &amp; -(a_{n-1} + \ell_{n-1}) }
\]</span> which has the OCF structure. Thus, <span class="math display">\[
\det(sI - (A - LC)) =
s^n + (a_{n-1} + \ell_{n-1}) s^{n-1} + \cdots + (a_1 + \ell_1) s + (a_0 + \ell_0).
\]</span> Observe that each component of the observer gain matrix <span class="math inline">\(L\)</span> affects only <em>one</em> coefficient of the characteristic polynomial. Thus, we can pick <span class="math display">\[
\bbox[5pt,border: 1px solid]
{L = \MATRIX{ Î±_0 - a_0 \\ \vdots \\ Î±_{n-1} - a_{n-1}} }
\]</span> to place the eigenvalues of <span class="math inline">\(A - LC\)</span> in the desired location.</p>
<div id="exm-OCF" class="theorem example">
<p><span class="theorem-title"><strong>Example 1</strong></span> Consider the system <span class="math display">\[
A = \MATRIX{ 0 &amp; -1 \\ 1 &amp; -2 }
\quad
C = \MATRIX{ 0 &amp; 1}
\]</span> Determine the observer gain <span class="math inline">\(L\)</span> such that the eigenvalues of <span class="math inline">\(A - LC\)</span> are at <span class="math inline">\(-10 \pm 5 j\)</span>.</p>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Solution
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The desired characteristic polynomial is <span class="math display">\[ (s+10)^2 + 5^2 = s^2 + 20s + 125. \]</span></p>
<p>The current characteristic polynomial is (since the system is in OCF, we can determine it by inspection) <span class="math display">\[ \det(sI - A) = s^2 + 2s + 1. \]</span></p>
<p>Therefore, the required output feedback gain is <span class="math display">\[ L = \MATRIX{ 125 - 1 \\ 20 - 2 } = \MATRIX{ 124 \\ 18 }. \]</span></p>
<p>We verify the solution below.</p>
<div id="c24076e2" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode julia code-with-copy"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="fl">0</span> <span class="op">-</span><span class="fl">1</span> ; <span class="fl">1</span> <span class="op">-</span><span class="fl">2</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> [<span class="fl">0</span>  <span class="fl">1</span>]</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> [<span class="op">-</span><span class="fl">10</span> <span class="op">+</span> <span class="fl">5im</span>, <span class="op">-</span><span class="fl">10</span> <span class="op">-</span> <span class="fl">5im</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="fu">place</span>(A<span class="op">'</span>,C<span class="op">'</span>,p)<span class="ch">'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>2Ã—1 adjoint(::Matrix{ComplexF64}) with eltype ComplexF64:
 124.0 - 0.0im
  18.0 - 0.0im</code></pre>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="observer-design-for-systems-not-in-ocf" class="level2 page-columns page-full" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="observer-design-for-systems-not-in-ocf"><span class="header-section-number">3</span> Observer design for systems not in OCF</h2>
<p>When a system is not in OCF, we can still use the design of systems in OCF if there is a transformation (or change of coordinates) <span class="math inline">\(x_o(t) = T^{-1} x(t)\)</span> such that the transformed matrices <span class="math inline">\((A_o, B_o, C_o)\)</span> are in OCF. If such a transformation can be found, then we can find the observer gain <span class="math inline">\(L_o\)</span> for the system in OCF using the method of the previous section and use<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <span class="math display">\[
  L = T L_o
\]</span> as the observer gain for the original system. So, as was the case for state feedback, the main question is: how do we find such a transformation?</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;The Luenberger observer for the new coordinate system is <span class="math display">\[
\dot {\hat x_o}(t) = A_o \hat x_o(t) + B_o u(t) + L_o(y(t) - C_o \hat x_o(t)).
\]</span> Substituting the values of <span class="math inline">\((A_o, B_o, C_o)\)</span>, we get <span class="math display">\[\begin{align*}
\dot {\hat x_o}(t)
&amp;= T^{-1} A T \hat x_o(t) + T^{-1} B u(t) + L_o( y(t) - C T \hat x_o(t)) \\
&amp;= T^{-1} A \hat x(t) + T^{-1} B u(t) + L_o(y(t) - C \hat x(t))
\end{align*}\]</span> where we have used the fact that <span class="math inline">\(\hat x_o(t) = T \hat x(t)\)</span>. Multiplying both sides by <span class="math inline">\(T\)</span>, we get <span class="math display">\[
\dot {\hat x}(t) = A \hat x(t) + B u(t) + T L_o(y(t) - C \hat x(t)).
\]</span> Hence, <span class="math inline">\(L = T L_o\)</span>.</p></div></div><section id="observability-matrix" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="observability-matrix"><span class="header-section-number">3.1</span> Observability matrix</h3>
<p>The observability matrix of a state space system <span class="math inline">\((A,C)\)</span> is defined as <span class="math display">\[
\mathcal O_{(A,C)} = \MATRIX{C \\ CA \\ \vdots \\ C A^{n-1}}
\]</span> Now consider a change of coordinates <span class="math inline">\(x_o(t) = T^{-1} x(t)\)</span>. Recall that the state space representation in the new coordinate system is <span class="math display">\[
A_o = T^{-1} A T,
\quad
C_o = C T.
\]</span></p>
<p>Observe that</p>
<ul>
<li><span class="math inline">\(A_o^2 = T^{-1} A T T^{-1} A T = T^{-1} A^2 T\)</span></li>
<li><span class="math inline">\(A_o^3 = T^{-1} A^2 T T^{-1} A T = T^{-1} A^3 T\)</span></li>
<li>etc.</li>
</ul>
<p>Therefore,</p>
<ul>
<li><span class="math inline">\(C_o A_o = C T T^{-1} A T = C A T\)</span></li>
<li><span class="math inline">\(C_o A_o^2 = C T T^{-1} A^2 T = C A^2 T\)</span></li>
<li>etc.</li>
</ul>
<p>Therefore, the observability matrix of the system in the new coordinate system is <span class="math display">\[\begin{align*}
  \mathcal O_{(A_o, B_o)}
  % &amp;= \MATRIX{ C_o \\ C_o A_o \\ \vdots \\ C_o A_o^{n-1} } \\
  &amp;= \MATRIX{ C T \\ C A T \\ \vdots \\ C A^{n-1} T } \\
  &amp;= \MATRIX{ C  \\ C A  \\ \vdots \\ C A^{n-1}  } T \\
  &amp;= \mathcal O_{(A,C)} T.
\end{align*}\]</span></p>
<p>Thus, we can go from SSM <span class="math inline">\((A,C)\)</span> to SSM <span class="math inline">\((A_o,C_o)\)</span> using the transformation <span class="math display">\[
  T = \mathcal O_{(A,C)}^{-1} \mathcal O_{(A_o, C_o)}
\]</span> <em>provided <span class="math inline">\(\mathcal O_{(A,C)}\)</span> is invertible</em> (i.e., has full rank). When that is the case, we say that the system is <strong>observable</strong>.</p>
</section>
<section id="observer-design" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="observer-design"><span class="header-section-number">3.2</span> Observer design</h3>
<p>The general observer design problem is as follows. We are given a system <span class="math inline">\((A,C)\)</span> not in OCF and we want to design a Luenberger observer <span class="math display">\[
\dot {\hat x}(t) = A \hat x(t) + B u(t) + L (y(t) - C \hat x(t)),
\quad \text{where }
L = \MATRIX{\ell_0 \\ \vdots \\ \ell_{n-1}}
\]</span> such that the characteristic polynomial of <span class="math inline">\(A - LC\)</span> is <span class="math display">\[
\det(sI _ A + LC) = s^n + Î±_{n-1} s^{n-1} + \cdots + Î±_0.
\]</span> We present two methods for observer design.</p>
<section id="method-1-using-observability-matrix" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="method-1-using-observability-matrix">Method 1: Using observability matrix</h4>
<ol type="1">
<li><p>Find the observability matrix <span class="math inline">\(\mathcal O_{(A,C)}\)</span> of the system.</p></li>
<li><p>If the system is not observable, i.e., the observability matrix is not full rank (which can be tested by checking that the determinant of the observability matrix is non-zero), observer design is not possible and we quit the procedure.</p></li>
<li><p>If the system is observable, find the characteristic polynomial of <span class="math inline">\(A\)</span>: <span class="math display">\[\det(s I - A) = s^n + a_{n-1} s^{n-1} + \cdots + a_0 \]</span></p></li>
<li><p>Using the above characteristic polynomial, write the SSM <span class="math inline">\((A_o, C_o)\)</span> in OCF.</p>
<p><span class="text-smaller">Recall that the characteristic polynomial is the denominator of the transfer function</span></p></li>
<li><p>Compute the observability matrix <span class="math inline">\(\mathcal O(A_o, C_o)\)</span> of the system <span class="math inline">\((A_o, B_o)\)</span> in OCF.</p></li>
<li><p>Compute the transformation <span class="math display">\[\bbox[5pt,border: 1px solid]{
T = \mathcal O_{(A, C)}^{-1} \mathcal O_{(A_o,C_o)}
}\]</span></p></li>
<li><p>Compute the observer gain <span class="math inline">\(L_o\)</span> for the system in OCF: <span class="math display">\[ L_o = \MATRIX{ Î±_0 - a_0 \\ \vdots \\ Î±_{n-1} - a_{n-1}}. \]</span></p></li>
<li><p>The controller gain for the original system is <span class="math display">\[L = T L_o.\]</span></p></li>
</ol>
</section>
<section id="method-2-a-slightly-more-efficient-approach" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="method-2-a-slightly-more-efficient-approach">Method 2: A slightly more efficient approach</h4>
<p>It is possible to avoid the computation of the observability matrix of the system in OCF by replacing steps 4â€“6 of Method 1 by the following:</p>
<ol start="4" type="1">
<li><p>Compute the matrix <span class="math display">\[ W = \MATRIX{ a_1 &amp; a_2 &amp; \cdots &amp; a_{n-1} &amp; 1 \\
                a_2 &amp; \iddots &amp; \iddots &amp; 1 &amp; 0 \\
                \iddots &amp; \iddots &amp; \iddots &amp; \iddots &amp; \vdots \\
               a_{n-1} &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\
               1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0
              }
\]</span></p></li>
<li><p>Compute the transformation: <span class="math display">\[\bbox[5pt,border: 1px solid]{
T = \bigl[ W \mathcal O_{(A,C)} \bigr]^{-1}
}\]</span></p></li>
</ol>
<p>This method relies on the fact that for a system <span class="math inline">\((A_o,C_o)\)</span> in OCF, <span class="math inline">\(\mathcal O_{(A_o,C_o)} = W^{-1}\)</span>. For a proof, see Lemma 4.5 of William and Lawrence.</p>
<div id="exm-observer-design" class="theorem example">
<p><span class="theorem-title"><strong>Example 2</strong></span> Consider the following SSM: <span class="math display">\[ A = \MATRIX{3 &amp; 1 \\ 1 &amp; 2}, B = \MATRIX{2 \\1} \text{ and } C = \MATRIX{ 3 &amp; 2}. \]</span> Design a Luenberger observer (i.e., compute the observer gain <span class="math inline">\(L\)</span>) such that the eigenvalues of <span class="math inline">\(A - LC\)</span> are at <span class="math inline">\(-10 \pm 5j\)</span>.</p>
</div>
</section>
</section>
</section>
<section id="output-feedback" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="output-feedback"><span class="header-section-number">4</span> Output feedback</h2>
<p>Consider a SSM <span class="math display">\[\begin{align*}
\dot x(t) &amp;= A x(t) + B u(t) \\
y(t) &amp;= C x(t)
\end{align*}\]</span></p>
<p>In this section, we will learn how to control such a system when the controller does not have access to the internal state <span class="math inline">\(x(t)\)</span>, but can only observe the output <span class="math inline">\(y(t)\)</span>. This is called <strong>output feedback</strong>.</p>
<div id="fig-block" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figures/svg/SSM2.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-block-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Block diagram for output feedback
</figcaption>
</figure>
</div>
<p>The basic idea of output feedback is to first estimate the state of the system via a Luenberger observer <span class="math display">\[
\dot {\hat x}(t) = A \hat x(t) + B u(t) + L (y(t) - C \hat x(t)),
\quad\text{where }
L = \MATRIX{\ell_0 \\ \vdots \\ \ell_{n-1}}
\]</span> and then use a linear feedback controller that uses the estimated state: <span class="math display">\[
  u(t) = - K \hat x(t),
\quad\text{where }
K = \MATRIX{k_0 &amp; \cdots &amp; k_{n-1}}.
\]</span></p>
<p>As before, we will first consider the system without any reference signal, i.e., <span class="math inline">\(r(t) = 0\)</span>. In tihs case, there are <span class="math inline">\(2n\)</span> tunable gains <span class="math inline">\(k_0, \dots, k_{n-1}\)</span> and <span class="math inline">\(\ell_0, \dots, \ell_{n-1}\)</span> and the hope is that we can find these gain to arbitrarily choose the eigenvalues of the closed loop system.</p>
<p>Writing the above equations in state space form, we get <span class="math display">\[
\MATRIX{ \dot x(t) \\ \dot {\hat x}(t) } =
\MATRIX{ A &amp; -BK \\ LC &amp; A - BK - LC }
\MATRIX{ x(t) \\ \hat x(t) }.
\]</span> By using the transformation <span class="math inline">\(T = \MATRIX{I &amp; 0 \\ I &amp; -I}\)</span>, we get <span class="math display">\[
\MATRIX{ \dot x(t) \\ \dot e(t) } =
\MATRIX{ A - BK &amp; BK \\ 0 &amp; A - LC }
\MATRIX{ x(t) \\ e(t) }.
\]</span> Thus, the characteristic polynomial of the closed loop system is <span class="math display">\[
\DET{ A - BK &amp; -BK \\ 0 &amp; A - LC }  =
\det(sI - (A - BK)) \det(sI - (A-LC))
\]</span> where we have used the fact that the determiniant of a block diagonal upper triangular matrix is the product of the determinants of the diagonal sub-matrices.</p>
<p>Thus, <span class="math display">\[
\{\text{eigenvalues of closed loop system}\}
= \{\text{eigenvalues of $(A - BK)$}\} \cup
  \{\text{eigenvalues of $(A - LC)$}\}.
\]</span> Thus, we can separately design the controller gain <span class="math inline">\(K\)</span> and the observer gain <span class="math inline">\(L\)</span> by using the methods described earlier. This is called <strong>the separation principle.</strong></p>
<p>If we choose observer poles several times faster than controller poles, the controller poles will dominate. Thus, output feedback gives essentially the same performance as (the non-implementable) state feedback.</p>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/adityam\.github\.io\/linear-systems\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/adityam/linear-systems/edit/quarto/output-feedback.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div></div></footer><script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>